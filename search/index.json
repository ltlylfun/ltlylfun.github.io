[{"content":"前言 本笔记不是零基础笔记\nReact 组件名称 React 组件是常规的 JavaScript 函数，但 组件的名称必须以大写字母开头，否则它们将无法运行！\njsx 的规则 jsx 的 return 这个组件返回一个带有 src 和 alt 属性的 标签。 写得像 HTML，但实际上是 JavaScript！这种语法被称为 JSX，它允许你在 JavaScript 中嵌入标签。\n返回语句可以全写在一行上，如下面组件中所示：\n1return \u0026lt;img src=\u0026#34;https://i.imgur.com/MK3eW3As.jpg\u0026#34; alt=\u0026#34;Katherine Johnson\u0026#34; /\u0026gt;; 但是，如果你的标签和 return 关键字不在同一行，则必须把它包裹在一对括号中，如下所示：\n1return ( 2 \u0026lt;div\u0026gt; 3 \u0026lt;img src=\u0026#34;https://i.imgur.com/MK3eW3As.jpg\u0026#34; alt=\u0026#34;Katherine Johnson\u0026#34; /\u0026gt; 4 \u0026lt;/div\u0026gt; 5); 没有括号包裹的话，任何在 return 下一行的代码都 将被忽略！\nJSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。\n标签必须闭合 JSX 要求标签必须正确闭合。像 \u0026lt;img\u0026gt; 这样的自闭合标签必须书写成 \u0026lt;img /\u0026gt;，而像 \u0026lt;li\u0026gt;oranges 这样只有开始标签的元素必须带有闭合标签，需要改为 \u0026lt;li\u0026gt;oranges\u0026lt;/li\u0026gt;。\n使用驼峰式命名法给 所有 大部分属性命名！ JSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。在你自己的组件中，经常会遇到需要用变量的方式读取这些属性的时候。但 JavaScript 对变量的命名有限制。例如，变量名称不能包含 - 符号或者像 class 这样的保留字。\n这就是为什么在 React 中，大部分 HTML 和 SVG 属性都用驼峰式命名法表示。例如，需要用 strokeWidth 代替 stroke-width。由于 class 是一个保留字，所以在 React 中需要用 className 来代替。这也是 DOM 属性中的命名。\n默认导出与具名导出 语法 导出语句 导入语句 默认 export default function Button() {} import Button from './Button.js'; 具名 export function Button() {} import { Button } from './Button.js'; 一个文件里有且仅有一个 默认 导出，但是可以有任意多个 具名 导出。\n当使用默认导入时，你可以在 import 语句后面进行任意命名。比如 import Banana from \u0026lsquo;./Button.js\u0026rsquo;，如此你能获得与默认导出一致的内容。相反，对于具名导入，导入和导出的名字必须一致。这也是称其为 具名 导入的原因！\n通常，文件中仅包含一个组件时，人们会选择默认导出，而当文件中包含多个组件或某个值需要导出时，则会选择具名导出。 无论选择哪种方式，请记得给你的组件和相应的文件命名一个有意义的名字。不建议创建未命名的组件，比如 export default () =\u0026gt; {}，因为这样会使得调试变得异常困难。\n在大括号 { } 中使用 JavaScript 在 JSX 中，只能在以下两种场景中使用大括号 用作 JSX 标签内的文本：\u0026lt;h1\u0026gt;{name}'s To Do List\u0026lt;/h1\u0026gt;是有效的，但是 \u0026lt;{tag}\u0026gt;Gregorio Y. Zara's To Do List\u0026lt;/{tag}\u0026gt; 无效。 用作紧跟在 = 符号后的 属性：src={avatar} 会读取 avatar 变量，但是 src=\u0026quot;{avatar}\u0026quot; 只会传一个字符串 {avatar}。\n使用 “双大括号”：JSX 中的 CSS 和 对象 除了字符串、数字和其它 JavaScript 表达式，你甚至可以在 JSX 中传递对象。对象也用大括号表示，例如 { name: \u0026quot;Hedy Lamarr\u0026quot;, inventions: 5 }。因此，为了能在 JSX 中传递，你必须用另一对额外的大括号包裹对象：person={{ name: \u0026quot;Hedy Lamarr\u0026quot;, inventions: 5 }}。\n你可能在 JSX 的内联 CSS 样式中就已经见过这种写法了。React 不要求你使用内联样式（使用 CSS 类就能满足大部分情况）。但是当你需要内联样式的时候，你可以给 style 属性传递一个对象：\n1export default function TodoList() { 2 return ( 3 \u0026lt;ul style={{ 4 backgroundColor: \u0026#39;black\u0026#39;, 5 color: \u0026#39;pink\u0026#39; 6 }}\u0026gt; 7 \u0026lt;li\u0026gt;Improve the videophone\u0026lt;/li\u0026gt; 8 \u0026lt;li\u0026gt;Prepare aeronautics lectures\u0026lt;/li\u0026gt; 9 \u0026lt;li\u0026gt;Work on the alcohol-fuelled engine\u0026lt;/li\u0026gt; 10 \u0026lt;/ul\u0026gt; 11 ); 12} 注意，内联 style 属性 使用驼峰命名法编写。例如，HTML \u0026lt;ul style=\u0026quot;background-color: black\u0026quot;\u0026gt; 在你的组件里应该写成 \u0026lt;ul style={{ backgroundColor: 'black' }}\u0026gt;。\n所以当你下次在 JSX 中看到 {{ }}时，就知道它只不过是包在大括号里的一个对象罢了！\nprops 要传递 props，请将它们添加到 JSX，就像使用 HTML 属性一样。 要读取 props，请使用 function Avatar({ person, size }) 解构语法。 你可以指定一个默认值，如 size = 100，用于缺少值或值为 undefined 的 props 。 你可以使用 \u0026lt;Avatar {...props} /\u0026gt; JSX 展开语法转发所有 props，但不要过度使用它！ 像 \u0026lt;Card\u0026gt;\u0026lt;Avatar /\u0026gt;\u0026lt;/Card\u0026gt; 这样的嵌套 JSX，将被视为 Card 组件的 children prop。 Props 是只读的时间快照：每次渲染都会收到新版本的 props。 你不能改变 props。当你需要交互性时，你可以设置 state。 条件渲染 在 React，你可以使用 JavaScript 来控制分支逻辑。 你可以使用 if 语句来选择性地返回 JSX 表达式。 你可以选择性地将一些 JSX 赋值给变量，然后用大括号将其嵌入到其他 JSX 中。 在 JSX 中，{cond ? \u0026lt;A /\u0026gt; : \u0026lt;B /\u0026gt;} 表示 “当 cond 为真值时, 渲染 \u0026lt;A /\u0026gt;，否则 \u0026lt;B /\u0026gt;”。 在 JSX 中，{cond \u0026amp;\u0026amp; \u0026lt;A /\u0026gt;} 表示 “当 cond 为真值时, 渲染 ，否则不进行渲染”。 快捷的表达式很常见，但如果你更倾向于使用 if，你也可以不使用它们。 key 如何设定 key 值 不同来源的数据往往对应不同的 key 值获取方式：\n来自数据库的数据： 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。 本地产生数据： 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 uuid 的库来生成 key。\nkey 需要满足的条件 key 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。\nkey 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。\nReact 中为什么需要 key？ 设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……\nReact 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。\n保持组件纯粹 一个组件必须是纯粹的，就意味着：\n只负责自己的任务。 它不会更改在该函数调用前就已存在的对象或变量。 输入相同，则输出相同。 给定相同的输入，组件应该总是返回相同的 JSX。 渲染随时可能发生，因此组件不应依赖于彼此的渲染顺序。\n你不应该改变任何用于组件渲染的输入。这包括 props、state 和 context。通过 “设置” state 来更新界面，而不要改变预先存在的对象。\n努力在你返回的 JSX 中表达你的组件逻辑。当你需要“改变事物”时，你通常希望在事件处理程序中进行。作为最后的手段，你可以使用 useEffect。\n传递给事件的函数 传递一个函数（正确） 调用一个函数（错误） \u0026lt;button onClick={handleClick}\u0026gt; \u0026lt;button onClick={handleClick()}\u0026gt; 区别很微妙。在第一个示例中，handleClick 函数作为 onClick 事件处理函数传递。这会让 React 记住它，并且只在用户点击按钮时调用你的函数。\n在第二个示例中，handleClick() 中最后的 () 会在 渲染 过程中 立即 触发函数，即使没有任何点击。这是因为位于 JSX {} 之间的 JavaScript 会立即执行。\n传递一个函数（正确） 调用一个函数（错误） \u0026lt;button onClick={() =\u0026gt; alert('...')}\u0026gt; \u0026lt;button onClick={alert('...')}\u0026gt; 如果按如下方式传递内联代码，并不会在点击时触发，而是会在每次组件渲染时触发：\n1// 这个 alert 在组件渲染时触发，而不是点击时触发！ 2\u0026lt;button onClick={alert(\u0026#39;你点击了我！\u0026#39;)}\u0026gt; 如果你想要定义内联事件处理函数，请将其包装在匿名函数中，如下所示：\n1\u0026lt;button onClick={() =\u0026gt; alert(\u0026#39;你点击了我！\u0026#39;)}\u0026gt; 这里创建了一个稍后调用的函数，而不会在每次渲染时执行其内部代码。\n在这两种情况下，你都应该传递一个函数：\n\u0026lt;button onClick={handleClick}\u0026gt; 传递了 handleClick 函数。 \u0026lt;button onClick={() =\u0026gt; alert('...')}\u0026gt; 传递了 () =\u0026gt; alert(\u0026rsquo;\u0026hellip;\u0026rsquo;) 函数。 事件的传播 在 React 中所有事件都会传播，除了 onScroll，它仅适用于你附加到的 JSX 标签。\n阻止传播 事件处理函数接收一个 事件对象 作为唯一的参数。按照惯例，它通常被称为 e ，代表 “event”（事件）。你可以使用此对象来读取有关事件的信息。\n这个事件对象还允许你阻止传播。如果你想阻止一个事件到达父组件，你需可以调用 e.stopPropagation() ：\n1function Button({ onClick, children }) { 2 return ( 3 \u0026lt;button onClick={e =\u0026gt; { 4 e.stopPropagation(); 5 onClick(); 6 }}\u0026gt; 7 {children} 8 \u0026lt;/button\u0026gt; 9 ); 10} 11 12export default function Toolbar() { 13 return ( 14 \u0026lt;div className=\u0026#34;Toolbar\u0026#34; onClick={() =\u0026gt; { 15 alert(\u0026#39;你点击了 toolbar ！\u0026#39;); 16 }}\u0026gt; 17 \u0026lt;Button onClick={() =\u0026gt; alert(\u0026#39;正在播放！\u0026#39;)}\u0026gt; 18 播放电影 19 \u0026lt;/Button\u0026gt; 20 \u0026lt;Button onClick={() =\u0026gt; alert(\u0026#39;正在上传！\u0026#39;)}\u0026gt; 21 上传图片 22 \u0026lt;/Button\u0026gt; 23 \u0026lt;/div\u0026gt; 24 ); 25} 阻止默认行为 某些浏览器事件具有与事件相关联的默认行为。例如，点击 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面\n你可以调用事件对象中的 e.preventDefault() 来阻止这种情况发生\n1export default function Signup() { 2 return ( 3 \u0026lt;form onSubmit={e =\u0026gt; { 4 e.preventDefault(); 5 alert(\u0026#39;提交表单！\u0026#39;); 6 }}\u0026gt; 7 \u0026lt;input /\u0026gt; 8 \u0026lt;button\u0026gt;发送\u0026lt;/button\u0026gt; 9 \u0026lt;/form\u0026gt; 10 ); 11} useState 设置 state 不会更改现有渲染中的变量，但会请求一次新的渲染。 设置 state 的调用是在告诉 React：\u0026ldquo;组件状态已更新，请安排一个新的渲染周期来反映这一变化。\u0026rdquo;\n当你调用 setState 时，React 并不会立即修改当前渲染（即已经生成的虚拟 DOM）中的变量。这意味着，在当前的渲染过程中，你依然看到的是旧的状态值。\nsetState 调用其实是异步的。它会在内部标记组件需要更新，但真正的更新和重新渲染会在稍后的时机发生（通常是在事件处理结束或其他合适的时机）。更新后的状态会在下一次渲染时生效。\n当新的渲染触发后，React 会创建一个全新的虚拟 DOM，并使用更新后的 state 生成新的 UI，然后再比较前后两次虚拟 DOM 的变化，并只更新浏览器中实际变动的部分（即“调和”过程）。\n总结来说，设置 state 不会修改当前渲染的变量，它只是请求一次新的渲染，在下一个渲染周期中使用新的 state 来重新计算和更新 UI。这种机制有助于保持组件状态的不可变性和渲染的一致性。\nReact 会在事件处理函数执行完成之后处理 state 更新。这被称为批处理。 只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。这种特性也就是 批处理，它会使你的 React 应用运行得更快。它还会帮你避免处理只 ​​ 更新了一部分 state 变量的令人困惑的“半成品”渲染。\nReact 不会跨 多个 需要刻意触发的事件（如点击）进行批处理——每次点击都是单独处理的。请放心，React 只会在一般来说安全的情况下才进行批处理。这可以确保，例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。\n要在一个事件中多次更新某些 state，你可以使用 setNumber(n =\u0026gt; n + 1) 更新函数。 将 state 视为只读的 1onPointerMove={e =\u0026gt; { 2 position.x = e.clientX; 3 position.y = e.clientY; 4}} 这段代码直接修改了 上一次渲染中 分配给 position 的对象。但是因为并没有使用 state 的设置函数，React 并不知道对象已更改。所以 React 没有做出任何响应。虽然在一些情况下，直接修改 state 可能是有效的，但并不推荐这么做。你应该把在渲染过程中可以访问到的 state 视为只读的。\n在这种情况下，为了真正地 触发一次重新渲染，你需要创建一个新对象并把它传递给 state 的设置函数：\n1onPointerMove={e =\u0026gt; { 2 setPosition({ 3 x: e.clientX, 4 y: e.clientY 5 }); 6}} 通过使用 setPosition，你在告诉 React：\n使用这个新的对象替换 position 的值,然后再次渲染这个组件\n局部 mutation 是可以接受的 像这样的代码是有问题的，因为它改变了 state 中现有的对象：\n1position.x = e.clientX; 2position.y = e.clientY; 但是像这样的代码就 没有任何问题，因为你改变的是你刚刚创建的一个新的对象：\n1const nextPosition = {}; 2nextPosition.x = e.clientX; 3nextPosition.y = e.clientY; 4setPosition(nextPosition); 事实上，它完全等同于下面这种写法：\n1setPosition({ 2 x: e.clientX, 3 y: e.clientY 4}); 只有当你改变已经处于 state 中的 现有 对象时，mutation 才会成为问题。而修改一个你刚刚创建的对象就不会出现任何问题，因为 还没有其他的代码引用它。改变它并不会意外地影响到依赖它的东西。这叫做“局部 mutation”。你甚至可以 在渲染的过程中 进行“局部 mutation”的操作。这种操作既便捷又没有任何问题！\n使用展开语法复制对象 下面这行代码修改了上一次渲染中的 state：\n1person.firstName = e.target.value; 想要实现你的需求，最可靠的办法就是创建一个新的对象并将它传递给 setPerson。但是在这里，你还需要 把当前的数据复制到新对象中，因为你只改变了其中一个字段：\n1setPerson({ 2 firstName: e.target.value, // 从 input 中获取新的 first name 3 lastName: person.lastName, 4 email: person.email 5}); 你可以使用...对象展开 语法，这样你就不需要单独复制每个属性。\n1setPerson({ 2 ...person, // 复制上一个 person 中的所有字段 3 firstName: e.target.value // 但是覆盖 firstName 字段 4}); 对于大型表单，将所有数据都存放在同一个对象中是非常方便的——前提是你能够正确地更新它！\n请注意...展开语法本质是是“浅拷贝”——它只会复制一层。这使得它的执行速度很快，但是也意味着当你想要更新一个嵌套属性时，你必须得多次使用展开语法。\n更新一个嵌套对象 考虑下面这种结构的嵌套对象：\n1const [person, setPerson] = useState({ 2 name: \u0026#39;Niki de Saint Phalle\u0026#39;, 3 artwork: { 4 title: \u0026#39;Blue Nana\u0026#39;, 5 city: \u0026#39;Hamburg\u0026#39;, 6 image: \u0026#39;https://i.imgur.com/Sd1AgUOm.jpg\u0026#39;, 7 } 8}); 如果你想要更新 person.artwork.city 的值，用 mutation 来实现的方法非常容易理解：\n1person.artwork.city = \u0026#39;New Delhi\u0026#39;; 但是在 React 中，你需要将 state 视为不可变的！为了修改 city 的值，你首先需要创建一个新的 artwork 对象（其中预先填充了上一个 artwork 对象中的数据），然后创建一个新的 person 对象，并使得其中的 artwork 属性指向新创建的 artwork 对象：\n1const nextArtwork = { ...person.artwork, city: \u0026#39;New Delhi\u0026#39; }; 2const nextPerson = { ...person, artwork: nextArtwork }; 3setPerson(nextPerson); 或者，写成一个函数调用：\n1setPerson({ 2 ...person, // 复制其它字段的数据 3 artwork: { // 替换 artwork 字段 4 ...person.artwork, // 复制之前 person.artwork 中的数据 5 city: \u0026#39;New Delhi\u0026#39; // 但是将 city 的值替换为 New Delhi！ 6 } 7}); 使用 Immer 编写简洁的更新逻辑 如果你的 state 有多层的嵌套，你或许应该考虑 将其扁平化。但是，如果你不想改变 state 的数据结构，你可能更喜欢用一种更便捷的方式来实现嵌套展开的效果。Immer 是一个非常流行的库，它可以让你使用简便但可以直接修改的语法编写代码，并会帮你处理好复制的过程。通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象：\n1updatePerson(draft =\u0026gt; { 2 draft.artwork.city = \u0026#39;Lagos\u0026#39;; 3}); 但是不同于一般的 mutation，它并不会覆盖之前的 state！\n尝试使用 Immer:\n运行 npm install use-immer 添加 Immer 依赖 用 import { useImmer } from 'use-immer' 替换掉 import { useState } from 'react' 在没有 mutation 的前提下更新数组 在 JavaScript 中，数组只是另一种对象。同对象一样，你需要将 React state 中的数组视为只读的。这意味着你不应该使用类似于 arr[0] = \u0026lsquo;bird\u0026rsquo; 这样的方式来重新分配数组中的元素，也不应该使用会直接修改原始数组的方法，例如 push() 和 pop()。\n相反，每次要更新一个数组时，你需要把一个新的数组传入 state 的 setting 方法中。为此，你可以通过使用像 filter() 和 map() 这样不会直接修改原始值的方法，从原始数组生成一个新的数组。然后你就可以将 state 设置为这个新生成的数组。\n下面是常见数组操作的参考表。当你操作 React state 中的数组时，你需要避免使用左列的方法，而首选右列的方法：\n操作 避免使用 (会改变原始数组) 推荐使用 (会返回一个新数组） 添加元素 push，unshift concat，[\u0026hellip;arr] 展开语法 删除元素 pop，shift，splice filter，slice 替换元素 splice，arr[i] = \u0026hellip; 赋值 map 排序 reverse，sort 先将数组复制一份 useRef 给你的组件添加 ref 你可以通过从 React 导入 useRef Hook 来为你的组件添加一个 ref：\n1import { useRef } from \u0026#39;react\u0026#39;; 在你的组件内，调用 useRef Hook 并传入你想要引用的初始值作为唯一参数。例如，这里的 ref 引用的值是“0”：\n1const ref = useRef(0); useRef 返回一个这样的对象:\n1{ 2 current: 0 // 你向 useRef 传入的值 3} 与 state 不同的是，ref 是一个普通的 JavaScript 对象，具有可以被读取和修改的 current 属性。\n你可以用 ref.current 属性访问该 ref 的当前值。这个值是有意被设置为可变的，意味着你既可以读取它也可以写入它。就像一个 React 追踪不到的、用来存储组件信息的秘密“口袋”。（这就是让它成为 React 单向数据流的“脱围机制”的原因）\nref 和 state 的不同之处 useRef useState 返回值 useRef(initialValue) 返回 { current: initialValue } useState(initialValue) 返回 [value, setValue] 触发渲染 更改时不会触发重新渲染 更改时触发重新渲染 可变性 可变 —— 你可以在渲染过程之外修改和更新 current 的值。 “不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。 读取/写入时机 你不应在渲染期间读取（或写入） current 值。 你可以随时读取 state。但是，每次渲染都有自己不变的 state 快照。 使用 ref 操作 DOM 要访问由 React 管理的 DOM 节点，首先，引入 useRef Hook：\n1import { useRef } from \u0026#39;react\u0026#39;; 然后，在你的组件中使用它声明一个 ref：\n1const myRef = useRef(null); 最后，将 ref 作为 ref 属性值传递给想要获取的 DOM 节点的 JSX 标签：\n1\u0026lt;div ref={myRef}\u0026gt; useRef Hook 返回一个对象，该对象有一个名为 current 的属性。最初，myRef.current 是 null。当 React 为这个 创建一个 DOM 节点时，React 会把对该节点的引用放入 myRef.current。然后，你可以从 事件处理器 访问此 DOM 节点，并使用在其上定义的内置浏览器 API。\n1// 你可以使用任意浏览器 API，例如： 2myRef.current.scrollIntoView(); useEffect 如何编写 Effect 要编写一个 Effect, 请遵循以下三个步骤：\n声明 Effect。通常 Effect 会在每次 提交 后运行。 指定 Effect 依赖。大多数 Effect 应该按需运行，而不是在每次渲染后都运行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。你将通过指定 依赖项 来学习如何控制这一点。 必要时添加清理操作。一些 Effect 需要指定如何停止、撤销，或者清除它们所执行的操作。例如，“连接”需要“断开”，“订阅”需要“退订”，而“获取数据”需要“取消”或者“忽略”。你将学习如何通过返回一个 清理函数 来实现这些。 注意事项 每当你的组件渲染时，React 会先更新页面，然后再运行 useEffect 中的代码。换句话说，useEffect 会“延迟”一段代码的运行，直到渲染结果反映在页面上。\n默认情况下，Effect 会在 每次 渲染后运行。正因如此，以下代码会陷入死循环：\n1const [count, setCount] = useState(0); 2useEffect(() =\u0026gt; { 3 setCount(count + 1); 4}); 没有依赖数组和使用空数组 [] 作为依赖数组，行为是不同的： 1useEffect(() =\u0026gt; { 2 // 这里的代码会在每次渲染后运行 3}); 4 5useEffect(() =\u0026gt; { 6 // 这里的代码只会在组件挂载（首次出现）时运行 7}, []); 8 9useEffect(() =\u0026gt; { 10 // 这里的代码不但会在组件挂载时运行，而且当 a 或 b 的值自上次渲染后发生变化后也会运行 11}, [a, b]); 为什么依赖数组中可以省略 ref?\n这是因为 ref 具有 稳定 的标识：React 确保你在 每轮渲染中调用同一个 useRef 时，总能获得相同的对象。ref 不会改变，所以它不会导致重新运行 Effect。因此，在依赖数组中它可有可无。\nuseState 返回的 set 函数 也具有稳定的标识，因此它们通常也会被省略。如果在省略某个依赖项时 linter 不会报错，那么这么做就是安全的。\n省略始终稳定的依赖项仅在 linter 能“看到”对象是稳定的时候才有效。例如，如果 ref 是从父组件传递过来的，则必须在依赖数组中指定它。这很有必要，因为你无法确定父组件是一直传递相同的 ref，还是根据条件传递不同的 ref。所以，你的 Effect 会依赖于被传递的是哪个 ref。\nReact 会在每次 Effect 重新运行之前调用清理函数，并在组件卸载（被移除）时最后一次调用清理函数。\nuseMemo(性能优化的手段) 用法 1import { useMemo } from \u0026#39;react\u0026#39;; 2 3function TodoList({ todos, tab, theme }) { 4 const visibleTodos = useMemo(() =\u0026gt; filterTodos(todos, tab), [todos, tab]); 5 // ... 6} 你需要给 useMemo 传递两样东西：\n一个没有任何参数的 calculation 函数，像这样 () =\u0026gt;，并且返回任何你想要的计算结果。 一个由包含在你的组件中并在 calculation 中使用的所有值组成的 依赖列表。 在初次渲染时，你从 useMemo 得到的 值 将会是你的 calculation 函数执行的结果。\n在随后的每一次渲染中，React 将会比较前后两次渲染中的 所有依赖项 是否相同。如果通过 Object.is 比较所有依赖项都没有发生变化，那么 useMemo 将会返回之前已经计算过的那个值。否则，React 将会重新执行 calculation 函数并且返回一个新的值。\n换言之，useMemo 在多次重新渲染中缓存了 calculation 函数计算的结果直到依赖项的值发生变化。\nuseCallback 用法 当你优化渲染性能的时候，有时需要缓存传递给子组件的函数。让我们先关注一下如何实现，稍后去理解在哪些场景中它是有用的。\n为了缓存组件中多次渲染的函数，你需要将其定义在 useCallback Hook 中：\n1import { useCallback } from \u0026#39;react\u0026#39;; 2 3function ProductPage({ productId, referrer, theme }) { 4 const handleSubmit = useCallback((orderDetails) =\u0026gt; { 5 post(\u0026#39;/product/\u0026#39; + productId + \u0026#39;/buy\u0026#39;, { 6 referrer, 7 orderDetails, 8 }); 9 }, [productId, referrer]); 10 // ... 你需要传递两个参数给 useCallback：\n在多次渲染中需要缓存的函数\n函数内部需要使用到的所有组件内部值的 依赖列表。 初次渲染时，在 useCallback 处接收的 返回函数 将会是已经传入的函数。 在之后的渲染中，React 将会使用 Object.is 把 当前的依赖 和已传入之前的依赖进行比较。如果没有任何依赖改变，useCallback 将会返回与之前一样的函数。否则 useCallback 将返回 此次 渲染中传递的函数。\n简而言之，useCallback 在多次渲染中缓存一个函数，直至这个函数的依赖发生改变。\nuseCallback 与 useMemo 有何关系？ useMemo 经常与 useCallback 一同出现。当尝试优化子组件时，它们都很有用。他们会 记住（或者说，缓存）正在传递的东西：\n1import { useMemo, useCallback } from \u0026#39;react\u0026#39;; 2 3function ProductPage({ productId, referrer }) { 4 const product = useData(\u0026#39;/product/\u0026#39; + productId); 5 6 const requirements = useMemo(() =\u0026gt; { //调用函数并缓存结果 7 return computeRequirements(product); 8 }, [product]); 9 10 const handleSubmit = useCallback((orderDetails) =\u0026gt; { // 缓存函数本身 11 post(\u0026#39;/product/\u0026#39; + productId + \u0026#39;/buy\u0026#39;, { 12 referrer, 13 orderDetails, 14 }); 15 }, [productId, referrer]); 16 17 return ( 18 \u0026lt;div className={theme}\u0026gt; 19 \u0026lt;ShippingForm requirements={requirements} onSubmit={handleSubmit} /\u0026gt; 20 \u0026lt;/div\u0026gt; 21 ); 22} 区别在于你需要缓存 什么:\nuseMemo 缓存函数调用的结果。在这里，它缓存了调用 computeRequirements(product) 的结果。除非 product 发生改变，否则它将不会发生变化。这让你向下传递 requirements 时而无需不必要地重新渲染 ShippingForm。必要时，React 将会调用传入的函数重新计算结果。 useCallback 缓存函数本身。不像 useMemo，它不会调用你传入的函数。相反，它缓存此函数。从而除非 productId 或 referrer 发生改变，handleSubmit 自己将不会发生改变。这让你向下传递 handleSubmit 函数而无需不必要地重新渲染 ShippingForm。直至用户提交表单，你的代码都将不会运行。 如果你已经熟悉了 useMemo，你可能发现将 useCallback 视为以下内容会很有帮助：\n1// 在 React 内部的简化实现 2function useCallback(fn, dependencies) { 3 return useMemo(() =\u0026gt; fn, dependencies); 4} ","date":"2025-02-22T14:20:09+08:00","permalink":"https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ereact%E7%9A%84%E7%AC%94%E8%AE%B0/","title":"关于React的笔记"},{"content":"前言 关于 TCP/UDP 的笔记。\n希望这些笔记不仅能帮助自己系统梳理知识，也能为其他学习计算机网络的朋友提供借鉴。\nPS 不定时更新，欢迎讨论区留言。\n什么是 TCP？ TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。\n面向连接\n在发送数据之前，通信双方会先通过一个称为“三次握手”（3-way handshake）的过程建立一条可靠的传输连接。只有连接建立完成后，数据传输才能开始。是一对一的，不能像 UDP 一样一对多。\n可靠传输\nTCP 使用数据确认（ACK）、超时重传、重复确认（Duplicate ACK）等机制，确保数据包能够按顺序、完整地到达接收端。如果发生数据丢失或出错，TCP 能够自动进行重传，保证传输的可靠性。\n面向字节流\nTCP 将数据视为连续的字节流，而不是独立的数据包。这意味着在应用层数据的边界需要进行额外管理，例如通过消息分隔符或固定长度来标识每个独立的消息。\nTCP 与 UDP 对比表 方面 TCP UDP 面向连接 是，需要建立连接（三次握手）后才能进行数据传输 否，无连接，数据直接发送 数据可靠性 高，具备数据确认、重传机制、累积确认和错误校验等措施，确保数据准确无误到达 低，无内建确认和重传机制，数据可能丢失或乱序 数据顺序 保证按发送顺序到达 不保证顺序，数据包独立传输 流量控制 采用滑动窗口机制，根据接收方缓冲区大小动态控制数据发送速率 无，发送数据完全由应用层控制，可能导致接收端被淹没 拥塞控制 有，使用慢启动、拥塞避免、快速重传与快速恢复等算法，动态调整发送速率以应对网络拥塞 无，不具备拥塞控制，可能在网络繁忙时频繁丢包 错误检测与恢复 有，通过校验和及确认机制检测错误，并通过重传恢复丢失的数据 仅有基本的校验和，不能进行错误恢复 头部开销 较大，TCP 头部通常为 20 字节或以上，包含丰富的控制信息 较小，仅 8 字节，结构简单 连接管理 复杂，需经过三次握手建立连接及四次挥手断开连接，带来额外延时和资源开销 简单，无需连接建立和断开，适用于快速传输 实时性 相对较低，其可靠性保障和拥塞控制可能导致延迟上升，通常不适用于对延迟极度敏感的场景 高，延迟低，适合实时视频、在线游戏、VoIP 等对时效性要求较高的应用 适用场景 文件传输、网页浏览、电子邮件、数据库通信等需要高可靠性和数据顺序保证的应用 实时通讯、视频会议、在线游戏、DNS 查询、流媒体传输等可以容忍部分数据丢失，但要求低延迟的场景 TCP 和 UDP 可以使⽤同⼀个端⼝吗？ 可以的。\n在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。\n所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。\n传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。\n当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。\n序列号(SEQ)和初始序列号(ISN) 序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋 予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0。\n初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时 钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位 的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。\nTCP 三次握手过程 TCP 三次握手（Three-Way Handshake）是建立一个可靠的 TCP 连接的过程，通过交换控制信息来初始化连接参数。下面是详细的步骤：\n第一次握手（SYN）\n客户端向服务器发送一个带有 SYN 标志的报文段，该报文段包含客户端选择的初始序列号（ISN）。 该报文段表示客户端希望与服务器建立连接。 表示形式： 1客户端 → 服务器: SYN, Seq = x 第二次握手（SYN-ACK）\n服务器收到客户端的 SYN 后，发送一个包含 SYN 和 ACK 标志的报文段给客户端。 该报文段中，ACK 用来确认收到客户端的 SYN（Ack = x + 1），同时服务器也选择一个初始序列号（ISN = y）来建立自己的连接参数。 表示形式： 1服务器 → 客户端: SYN, ACK, Seq = y, Ack = x + 1 第三次握手（ACK）\n客户端在收到服务器的 SYN-ACK 后，再发送一个只带 ACK 标志的报文段，作为对服务器响应的确认。 该报文段中的 ACK 用来确认收到服务器的 SYN（Ack = y + 1）。 表示形式： 1客户端 → 服务器: ACK, Seq = x + 1, Ack = y + 1 当服务器收到这个 ACK 后，双方就建立了一个可靠的 TCP 连接，可以进行后续数据传输了。\n为什么需要三次握手，而不是两次或四次？ 「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双方资源的浪费，也⽆法可靠的同步双⽅序列号。\n「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。\nTCP 握手丢失情况 TCP 第一次握手丢失的情况 当第一次握手丢失时，TCP 将通过重传策略来尝试恢复连接，但如果问题持续存在，连接将建立失败并反馈错误信息给应用程序。\nTCP 第二次握手丢失的情况 当第二次握手丢失了，客户端和服务端都会重传。\n客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由内核参数决定。\n服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由内核参数决定。\nTCP 第三次握手丢失的情况 ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。直到收到第三次握⼿，或者达到最⼤重传次数。\nTCP 四次挥手过程 第一次挥手（FIN）\n客户端在没有数据发送后，向服务器发送一个带有 FIN 标志的报文段，以指示客户端不再有数据要发送。 表示形式： 1客户端 → 服务器: FIN, Seq = u 第二次挥手（ACK）\n服务器收到客户端的 FIN 报文段后，立即发送一个 ACK 报文段作为确认，表明已接收到客户端停止发送数据的请求。 表示形式： 1服务器 → 客户端: ACK, Seq = v, Ack = u + 1 此时，服务器可能仍有未传输完的数据，故数据传输方向上尚未完全关闭。 第三次挥手（FIN）\n当服务器完成剩余数据的传输后，会向客户端发送一个带有 FIN 标志的报文段，通知客户端服务器也没有数据要发送了，准备关闭连接。 表示形式： 1服务器 → 客户端: FIN, Seq = w 第四次挥手（ACK）\n客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段以确认收到服务器关闭连接的请求。 表示形式： 1客户端 → 服务器: ACK, Seq = u + 1, Ack = w + 1 为什么 TCP 挥手需要四次？ TCP 使用四次挥手断开连接，主要原因在于 TCP 连接是全双工的，也就是数据传输在两个方向上是独立的。在断开连接时，每个方向的数据传输都需要单独关闭。下面详细解释这一过程以及四次挥手的必要性：\n单向关闭\n当一方准备结束数据发送时，它只关闭自己的发送通道，但仍可接收数据。 例如，当客户端发送一个 FIN 时，它表示自己没有数据要发送了，但仍然可以接收服务器的数据。 独立的确认\n对于第一次 FIN（例如客户端发送的 FIN），服务器需要发送一个 ACK 来确认已经收到关闭请求。这只是对单个方向（客户端到服务器）的关闭确认。 接下来，服务器完成自身数据发送后，也需要发送 FIN 来关闭其发送通道，客户端再对其进行确认。 为何需要四次\n第一步（客户端 FIN）：客户端通知服务器“我已经没有数据要发送了”。 第二步（服务器 ACK）：服务器确认客户端的 FIN，并告知已接收，但此时仍可继续发送数据给客户端。 第三步（服务器 FIN）：当服务器也结束发送数据后，它通知客户端“我也没有数据要发送了”。 第四步（客户端 ACK）：客户端确认服务器的关闭请求，整个连接才能完全关闭。 可靠的连接终止\n四次挥手确保了双方在断开连接前都能完成数据传输与确认，避免数据丢失。 这种设计使得双方可以独立地结束各自的数据传输，从而达到安全、可靠地断开连接的目的。 什么情况会出现三次挥手？ 当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK(默认情 况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制)」，那么第二和第三 次挥手就会合并传输，这样就出现了三次挥手。\nTCP 挥手丢失情况 TCP 第一次挥手丢失的情况 当 TCP 第一次挥手的 FIN 报文丢失时，连接不会被立即关闭。主动关闭方会依赖重传机制来确保 FIN 最终传达到对方，一旦双方完成重传和确认，连接才会进入正常的终止流程。\nTCP 第二次挥手丢失的情况 ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。\nTCP 第三次挥手丢失的情况 当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。\n客户端因为是通过 close 函数关闭连接的，处于 FIN WAIT 2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手(FIN 报文)，那么客户端就会断开连接。\nTCP 第四次挥手丢失的情况 当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2，达到了最大重传次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。\n客户端在收到第三次挥手后，就会进入 TIME WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手(FIN 报文)后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。\n为什么需要 TIME_WAIT 状态？ 防止历史连接中的数据，被后面相同四元组的连接错误的接收。\n保证「被动关闭连接」的一方，能被正确的关闭。\n为什么每次建立 TCP 连接时，初始化的序列号都要求不一样？ 防止旧数据干扰\n如果使用固定或者可预测的序列号，网络中可能还残留有上一次连接的数据包，在新连接建立后，这些旧数据包可能会被误认为是当前连接的数据，从而导致数据混乱或连接异常。选择唯一的 ISN 可以避免这种数据干扰问题。\n确保数据流正确排序\nTCP 是一个面向字节流的协议，双方通过序列号来组织和排序数据。当每次连接的序列号都不相同时，可以确保即使出现重传或者网络延迟，接收方也能正确地将数据包按正确的顺序进行排序和重组。\n增强安全性\n可预测的序列号可能给攻击者提供利用的机会，例如 TCP 序列号预测攻击。因此，每次连接都使用一个不容易预测的初始序列号，可以有效提升连接的安全性，降低恶意攻击的风险。\n区分不同连接\n在同一对主机之间可能会在短时间内建立多个 TCP 连接。通过为每个连接选择不同的 ISN，可以帮助系统区分并管理这些连接，防止连接状态混淆。\n什么是 MTU 最大传输单元（英语：Maximum Transmission Unit，缩写 MTU）是指数据链路层上面所能通过的最大数据包大小（以字节为单位）。\n什么是 MSS？ 最大分段大小（Maximum Segment Size）是传输控制协议的一个参数，以字节数定义一个计算机或通信设备所能接受的分段的最大数据量。 它并不会计算 TCP 或 IP 协议头的大小。即最大传输单元除去信头后的最大数据量。\n为什么 TCP 层需要 MSS？ 降低 IP 分片的开销和风险\n分片开销：IP 分片不仅增加了每个数据包在网络上传输时的负担，还会影响路由器和接收主机的处理效率。每个分片都需要单独处理，如果分片过多，会导致额外的延时和资源消耗。 分片丢失问题：如果 IP 分片中的任一碎片丢失，整个数据包都必须重新传输。而且某些网络设备可能不支持 IP 分片或安全策略会丢弃分片，导致传输失败。 提高传输效率与可靠性\n匹配底层网络 MTU：TCP 在连接建立时协商并计算对端的 MSS，通常依据路径 MTU（Path MTU）来计算。这样可以确保 TCP 报文段在封装进 IP 数据报之后，不会超出最低链路的 MTU，从而避免触发 IP 分片。 优化数据传输：合理的 MSS 可以使得每个 TCP 报文段刚好适应底层网络的 MTU，最大限度地利用网络带宽，确保传输的连续性和高效性。 简化错误处理\n使用 MSS 限制 TCP 报文段大小可以降低由于 IP 分片引起的重传和错误处理的复杂度。如果发生数据丢失，整个 TCP 报文段丢失时，只需要重传一个比较小的单元，而不是一个由多个分片组成的大数据包。 协商与兼容性\n在 TCP 三次握手过程中，双方会交换 MSS 值，明确双方所能接受的最大报文段大小。这种协商有助于两端在一个共同的限制下进行通信，从而确保数据传输更加稳定和兼容不同网络环境。 TCP 的粘包、拆包以及解决方案 上图中演示了以下几种情况：\n正常的理想情况，两个包恰好满足 TCP 缓冲区的大小或达到 TCP 等待时长，分别发送两个包； 粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送； 拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送； 拆包和粘包：Packet1 过大，进行了拆包处理，而拆出去的一部分又与 Packet2 进行粘包处理。 什么是粘包？ 指 TCP 协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。\nTCP 是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。\n为什么 UDP 没有粘包？ 粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于 UDP 有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在 TCP 协议中。\n粘包拆包发生场景 因为 TCP 是面向流，没有边界，而操作系统在发送 TCP 数据时，会通过缓冲区来进行优化，例如缓冲区为 1024 个字节大小。\n如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。\n如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包。\n常见的解决方案 发送端将每个包都封装成固定的长度，比如 100 字节大小。如果不足 100 字节可通过补 0 或空等进行填充到指定长度； 发送端在每个包的末尾使用固定的分隔符，例如\\r\\n。如果发生拆包需等待多个包发送过来之后再找到其中的\\r\\n 进行合并；例如，FTP 协议； 将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息； 通过自定义协议进行粘包和拆包的处理。 重传机制 超时重传（以时间驱动） RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。\n超时重传时间是以 RTO(Retransmission Timeout 超时重传时间)表示。\n当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差。\n当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。\n快速重传（以数据驱动） 发送方发出了 1，2，3，4，5 份数据: 第一份 Seq1 先送到了，于是就 Ack 回 2;结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2;后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2 因为 Seq2 还是没有收到。\n发送端收到了三个 Ack =2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。\n最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6。\n所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。\n快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。\nSACK 方法 这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。\nDuplicate SACK 方法 Duplicate SACK 又称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。\n滑动窗口 TCP 滑动窗口是一种流量控制机制，用于管理在发送端和接收端之间传输的数据量，其基本原理如下：\n发送窗口\n发送端维护一个窗口，表示允许发送但尚未收到确认的数据范围。 接收窗口\n接收端根据自身缓冲区大小，通过 ACK 报文告知发送端当前可接收的数据量，这就是接收窗口。 窗口滑动\n当发送端收到 ACK 确认后，窗口向前移动，释放已确认的数据位置，从而可以继续发送新的数据。 这种“滑动”过程确保了数据的连续传输，同时防止发送端发送过多数据导致接收端溢出。 流量控制 TCP 流量控制是一种确保数据传输双方保持平衡的机制。其主要目标是：\n保护接收端：避免发送速率超过接收端处理能力，防止数据丢失或缓冲区溢出。 动态调整数据流：通过接收端反馈的窗口大小，发送端能够动态决定一次可以发送多少数据，确保高效且稳定的数据传输。 简单来说，TCP 流量控制就是通过交换窗口大小信息，使发送方根据接收方的当前处理能力来决定发送数据的速率，从而保持整个数据传输过程的可靠性和高效性。\n拥塞控制 TCP 拥塞控制是一种确保网络稳定和高效的数据传输机制，其主要目标是：\n预防网络拥塞：通过检测数据包丢失、延迟增大等现象，判断网络是否发生拥堵。 动态调整发送速率：在网络出现拥堵迹象时，降低发送窗口大小或发送速率；当网络状况改善时，逐步增加速率。 维护传输效率：在避免网络拥堵的同时，尽可能利用可用带宽实现高效的数据传输。 简单来说，TCP 拥塞控制就是通过动态调整数据发送速率来应对网络拥堵，确保数据传输既稳定又高效。\n","date":"2025-02-20T16:16:09+08:00","permalink":"https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/","title":"关于TCP/UDP的笔记"},{"content":"前言 关于 HTTP/HTTPS 的笔记。\n希望这些笔记不仅能帮助自己系统梳理知识，也能为其他学习计算机网络的朋友提供借鉴。\nPS 不定时更新，欢迎讨论区留言。\nHTTP 是什么？ HTTP 是一个在计算机世界里专门在【两点】之间【传输】文字、图片、音频、视频等【超文本】数据的【约定和规范】。\n常见的 HTTP 状态码 HTTP 状态码通常分为五大类：1xx、2xx、3xx、4xx 和 5xx，每一类代表一种响应类别。以下是一些常见的状态码：\n1xx（信息性状态码） 100 Continue：继续发送请求的剩余部分。 101 Switching Protocols：服务器正在根据客户端的请求切换协议。 2xx（成功状态码） 200 OK：请求成功，服务器返回请求的数据。 201 Created：请求成功，服务器创建了新的资源。 202 Accepted：请求已接受，但处理尚未完成。 204 No Content：请求成功，但没有内容返回。 3xx（重定向状态码） 301 Moved Permanently：请求的资源已被永久移动到新位置。 302 Found：请求的资源临时从不同的 URI 响应。 304 Not Modified：资源未修改，客户端可继续使用缓存的版本。 4xx（客户端错误状态码） 400 Bad Request：请求语法错误，服务器无法理解。 401 Unauthorized：请求要求身份验证。 403 Forbidden：服务器拒绝请求。 404 Not Found：请求的资源不存在。 405 Method Not Allowed：请求方法不被允许。 408 Request Timeout：请求超时。 5xx（服务器错误状态码） 500 Internal Server Error：服务器内部错误，无法完成请求。 501 Not Implemented：服务器不支持请求的功能。 502 Bad Gateway：作为网关或代理的服务器从上游服务器接收到无效响应。 503 Service Unavailable：服务器当前无法处理请求，通常是由于过载或维护。 504 Gateway Timeout：网关或代理服务器未及时从上游服务器收到响应。 GET 与 POST GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。\nPOST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。\nHTTP 各个版本比较 HTTP（超文本传输协议）是 Web 通信的基础协议，随着互联网的发展，HTTP 协议经过多次演变。本文档将介绍常见的 HTTP 版本及其主要特性和区别。\nHTTP/0.9 简介：是 HTTP 最早的版本，设计非常简单。 特点： 只支持 GET 方法。 不支持消息头和状态码。 主要用于获取简单的 HTML 文件。 限制：功能非常受限，无法应对复杂的需求，如状态管理或内容协商。 HTTP/1.0 简介：HTTP/1.0 在 1996 年作为 RFC 1945 发布，是对 HTTP/0.9 的扩展。 特点： 支持多种请求方法，如 GET、POST、HEAD。 引入了状态码和响应头，使得响应内容更加丰富。 每个请求后通常会关闭连接（非持久连接）。 限制： 每次请求都需建立新的 TCP 连接，导致效率较低。 不支持持久连接，无法处理多个请求。 HTTP/1.1 简介：HTTP/1.1 在 1997 年发布（RFC 2068），经过多次修订，是目前应用最广泛的版本。 特点： 支持持久连接（Connection: keep-alive），可以在同一连接上发送多个请求。 支持分块传输编码（chunked transfer encoding），使得数据流能够动态生成。 引入了更多的请求方法和头部字段，如 OPTIONS、PUT、DELETE 等。 支持管道化（pipelining），即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体响应时间。但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应，如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」，所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。 改进：相比于 HTTP/1.0, 在性能和灵活性上都有显著提升。 HTTP/2 简介：HTTP/2 在 2015 年作为 RFC 7540 发布，主要目标是提高性能和减少延迟。\n特点：\n基于二进制协议而不是文本协议，提高了解析效率和可靠性。\n支持多路复用（multiplexing），在单一 TCP 连接内同时发送多个请求和响应，减少了连接建立的开销。\n使用头部压缩（HPACK：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了），降低请求和响应头的传输量。\n支持服务器推送（Server Push），服务器可以主动推送资源到客户端，以减少等待时间。\nHTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而在 TCP 这一层。HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。\nHTTP/3 简介：HTTP/3 是 HTTP 协议的最新版本，目前处于快速发展阶段。HTTP/3 基于 QUIC 协议构建。\nHTTP/1.1 中的管道(pipeline)虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后，才能处理下一个请求，这属于 HTTP 层队头阻塞。HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。HTTP/2 队头阻塞的问题是因为 TCP，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP!\n特点：\n使用 QUIC 传输协议，基于 UDP 而非传统的 TCP。QUIC 结合了 TLS/SSL 加密功能，从而提高了安全性和连接建立速度。 支持多路复用，不存在 TCP 队头阻塞问题，即使某个流遇到问题也不会影响其他流。 连接恢复更快：在网络环境变化时（如网络切换），HTTP/3 能够更好地保持会话连续性。 改进：\n提供了更低的延迟、更快的连接建立速度以及更加可靠的传输体验。 总结 HTTP 版本 特点或改进 HTTP/0.9 最基础，仅支持 GET 请求，功能极其简单。 HTTP/1.0 引入状态码和头部，但每次请求都关闭连接。 HTTP/1.1 支持持久连接和多种请求方法，大大提高了传输效率。 HTTP/2 通过二进制传输、多路复用、头部压缩和服务器推送等特性进一步提升性能。 HTTP/3 采用 QUIC 协议，改善了连接建立和多路复用的性能，尤其在高延迟或不稳定网络环境下表现优异。 HTTP 与 HTTPS HTTP（超文本传输协议）和 HTTPS（安全超文本传输协议）是用于客户端与服务器之间通信的两种协议。它们在功能上相似，但在安全性和数据传输方式上存在重要区别。\nHTTP 定义：HTTP 是一种无状态、无连接的应用层协议，用于传输超文本（如 HTML）。 特点： 无加密：数据以明文形式传输，易受到窃听和中间人攻击。 端口：默认使用 80 端口。 性能：由于传输简单，开销较小，但安全性不足。 适用场景：适用于对数据安全性要求不高的场景或内部网络环境中。 HTTPS 定义：HTTPS 是基于 HTTP 协议并结合 TLS/SSL 加密层的安全传输协议。 特点： 加密传输：通过 TLS/SSL 对数据进行加密，保护数据传输过程中不被窃取或篡改。 身份验证：服务器需要通过数字证书进行身份验证，增强了信任度。 数据完整性：提供数据完整性校验，可以检测数据在传输中的任何异常修改。 端口：默认使用 443 端口。 适用场景：适用于要求高安全性的数据传输场景，如电子商务、在线银行、用户登录等。 HTTP 与 HTTPS 的比较 特性 HTTP HTTPS 加密 无加密，数据明文传输 使用 TLS/SSL 加密，保障数据安全 默认端口 80 443 数据安全性 低，易受中间人攻击和窃听 高，数据在传输过程中受到保护 网站信任度 通常用于公开信息传输，可以用在内容分发等场景 增强了用户信任，搜索引擎排名也通常给予 HTTPS 网站更多优势 实施成本 实现简单，无需额外配置 需要购买或申请 TLS/SSL 证书，配置相对复杂 TLS 握手的简单描述 blibli 技术蛋老师 https 视频\nClientHello\n客户端发起连接，发送 ClientHello 消息。 消息中包含客户端支持的 TLS 版本、加密套件以及一个随机数（Client Random）。 ServerHello 与服务器认证\n服务器收到 ClientHello 后，回复 ServerHello 消息，确认 TLS 版本和加密套件，并提供自己的随机数（Server Random）。 同时，服务器发送数字证书（Certificate），用于证明其身份（可选：还会发送密钥交换参数）。 ClientKeyExchange\n客户端验证服务器的证书后，生成一个预主密钥，并使用服务器的公钥对其进行加密后发送给服务器。 双方利用预主密钥以及交换的随机数计算出对称加密会话密钥。 Finished\n双方分别发送 Finished 消息。这些消息包含双方所有握手数据的摘要，用于验证握手过程的完整性。 握手完成后，后续的通信将使用协商的对称密钥加密传输数据。 HTTPS 中对称加密与非对称加密的简单描述（解决窃听风险） HTTPS 通过结合使用非对称加密和对称加密来确保通信的安全性。下面简单描述这两种加密方式在 HTTPS 中的作用：\n非对称加密：\n使用公钥和私钥进行加密和解密。 在 TLS 握手阶段，客户端使用服务器的公钥加密预主密钥，服务器使用私钥来解密，从而安全地交换密钥。 主要用于身份验证和密钥交换，虽然安全性高，但计算较慢。 对称加密：\n使用相同的密钥进行加密和解密。 TLS 握手完成后，客户端和服务器使用协商好的会话密钥对数据进行加密传输。 速度快，适用于大量数据的加密，但依赖密钥的安全交换。 HTTPS 中的摘要算法与数字签名的简单描述（解决篡改风险） 摘要算法：\n将任意长度的数据转换为固定长度的哈希值（或称消息摘要），其关键特点是单向性不可逆。\n作用：用于检测数据在传输过程中是否被篡改。 常见算法：例如 SHA-256，适用于确保数据完整性。 数字签名：\n结合摘要算法与非对称加密技术，实现对数据来源和完整性的验证。\n公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解 密的，只有持有私钥的人，才能解密出实际的内容;\n私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常 解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。\n过程：先对数据使用摘要算法生成哈希值，然后使用发送方的私钥对该哈希值进行加密，从而得到数字签名；接收方使用发送方的公钥解密签名，并与自己计算的哈希值进行比对。 作用：验证数据的真实性及防止数据被篡改。 HTTPS 数字证书的简单描述（解决冒充风险） HTTPS 数字证书是保障互联网通信安全的重要组成部分，用于验证服务器的身份并确保数据传输过程中的加密通信安全。\n数字证书是一种电子文档，其中包含以下信息：\n持有者信息：如服务器的名称、域名及其他标识信息。 公钥：用于加密数据或验证数字签名的公钥。 颁发机构信息：数字证书由受信任的第三方（称为证书颁发机构，CA）签发，确保证书的真实性。 有效期：证书的开始日期和截止日期。 数字签名：由证书颁发机构使用其私钥生成的签名，用于验证证书内容是否被篡改。 通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。\nHTTPS 是否可能被中间人截获？ HTTPS 设计的主要目标之一是防止中间人攻击（MITM）。通过使用 TLS/SSL 加密，HTTPS 确保了通信双方之间的数据在传输过程中是加密的，任何试图拦截的数据都难以解密或篡改。\n证书验证与信任链\n浏览器和客户端会验证服务器提供的数字证书，确保其由受信任的证书颁发机构（CA）签发。如果验证通过，客户端就会信任与服务器的连接。 如果攻击者能够伪造有效的证书或成功欺骗客户端（例如通过用户忽略警告），才有可能进行中间人攻击。 加密保护\n正确配置和使用 HTTPS 时，即使数据被中间人拦截，由于数据是加密的，攻击者也无法轻易解密和修改数据。 潜在风险\n配置错误：如果服务器使用了弱加密算法、过期或错误配置的证书，可能会降低安全性，使攻击者有机可乘。 CA 安全问题：一旦证书颁发机构（CA）受到攻击或存在漏洞，攻击者也可能利用伪造证书进行攻击。 HTTPS 中 RSA 与 ECDHE 简单比较 下表简单对比了 HTTPS 中使用的 RSA 与 ECDHE 两种密钥交换方式的主要区别：\n方面 RSA ECDHE 密钥交换方式 用 RSA 公钥加密预主密钥 基于椭圆曲线 Diffie-Hellman 临时密钥交换 前向保密性 无前向保密性；私钥泄露可能导致历史会话泄密 提供前向保密性；每次会话生成新的临时密钥 计算效率 依赖较长密钥，加密解密计算量大 密钥较短，计算更高效 安全性 基于大数分解难题，量子计算威胁较高 基于椭圆曲线离散对数问题，安全性更好 HTTP/1.1 优化思路？ 通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。\n第二个思路是，减少 HTTP 请求的次数，有以下的方法:\n将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数。 将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗。 按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。 通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。\n为什么需要 WebSocket？ 虽然 HTTP 协议已经在互联网应用中得到了广泛使用，但其设计理念是基于请求-响应模型，适合单向通信，即客户端发起请求，服务器返回响应。这种模型存在以下局限性：\n无状态连接：HTTP 是无状态的，每次请求都要重新建立连接，无法直接保持长时间的双向通信。 单向通信：服务器不能主动向客户端推送数据，所有通信都必须由客户端发起请求。 高延迟：频繁建立和断开连接会带来额外的延迟和资源开销，尤其在实时应用场景下不够高效。 为了解决这些局限性，WebSocket 协议应运而生，其主要优势包括：\n双向通信\nWebSocket 建立了一个持久连接，允许数据在客户端和服务器之间双向实时传输，不需要每次都重新建立连接。 低延迟\n一旦建立连接，数据交换无需重复 HTTP 请求头，降低了通信延迟，适合要求实时更新的应用场景，如在线游戏、金融交易、聊天应用等。 更高效的资源利用\n持久连接减少了频繁的连接建立和关闭开销，有助于减轻服务器压力，同时也降低了网络带宽消耗。 更灵活的应用场景\nWebSocket 可以实现实时数据推送，服务器可以主动发送数据给客户端，非常适合实现实时监控、协同编辑等需要快速交互的应用。 ","date":"2025-02-20T12:26:09+08:00","permalink":"https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ehttp/https%E7%9A%84%E7%AC%94%E8%AE%B0/","title":"关于HTTP/HTTPS的笔记"},{"content":"前言 在前端开发中，TypeScript 是一门非常重要的语言，它为 JavaScript 引入了静态类型检查，提升了代码的可靠性和可维护性，对于构建健壮的应用程序至关重要。\n希望这些笔记不仅能帮助自己梳理知识体系，也能为其他使用 TypeScript 的开发者提供参考和启发。\nPS 不定时更新，欢迎讨论区留言。\n类型系统 基本类型 在 TypeScript 中，类型系统包括许多基本类型，用于描述数据的不同形态。下面列出了常见的基本类型及其示例代码：\nboolean（布尔类型） 用于表示逻辑值 true 或 false。 1let isActive: boolean = true; string（字符串类型） 用于表示文本数据，可使用单引号、双引号或模板字符串。 1let greeting: string = \u0026#34;Hello, TypeScript!\u0026#34;; number（数字类型） 用于表示整数、浮点数、十六进制、二进制和八进制字面量。 1let age: number = 30; 2let hex: number = 0xf00d; 3let binary: number = 0b1010; 4let octal: number = 0o744; bigint（大整数类型） 用于表示大于 2^53 - 1 的整数。字面量后缀 n 用于标识 bigint 类型。 1let bigNumber: bigint = 123456789012345678901234567890n; symbol（符号类型） 用于创建独一无二的标识符，常用于对象属性的键。 1let uniqueKey: symbol = Symbol(\u0026#34;uniqueKey\u0026#34;); object（对象类型） 表示除基本类型之外的所有类型。用于描述具有属性的复合数据结构。 1let person: object = { name: \u0026#34;Alice\u0026#34;, age: 25 }; undefined（未定义类型） 表示未赋值状态，只有一个唯一值 undefined。 1let nothing: undefined = undefined; null（空值类型） 表示空或不存在的值，只有一个唯一值 null。 1let empty: null = null; 联合类型 在 TypeScript 中，联合类型（Union Types）允许一个变量可以是多个类型中的一个。使用 | 来分隔各个可能的类型，从而定义一个变量可能接受的所有类型。联合类型使得代码更具灵活性，同时保持静态类型检查的优势。\n例如，下面这个变量可以是数字或者字符串：\n1let value: number | string; 2value = 42; 3value = \u0026#34;Hello, TypeScript!\u0026#34;; 4 5// 如果赋值为其他类型，例如 boolean，则会报错： 6// value = true; // Error: Type \u0026#39;boolean\u0026#39; is not assignable to type \u0026#39;number | string\u0026#39;. 交叉类型 在 TypeScript 中，交叉类型（Intersection Types）允许你将多个类型合并为一个类型。当一个变量同时满足多个独立类型的要求时，就可以使用交叉类型。这种类型表示法使用 \u0026amp; 来连接各个类型，从而创建出一个新的类型，该类型包含所有合并类型的属性和方法。\n假设我们有两个接口，分别描述了不同的属性：\n1interface Person { 2 name: string; 3 age: number; 4} 5 6interface Employee { 7 employeeId: number; 8 department: string; 9} 我们可以使用交叉类型将这两个接口合并，创建一个既是 Person 又是 Employee 的类型：\n1type Manager = Person \u0026amp; Employee; 2 3const manager: Manager = { 4 name: \u0026#34;Alice\u0026#34;, 5 age: 30, 6 employeeId: 12345, 7 department: \u0026#34;Sales\u0026#34;, 8}; 在这个例子中，Manager 类型必须同时具有 Person 和 Employee 的所有属性。\ntype type命令用来定义一个类型的别名。\n1type Age = number; 2 3let age:Age = 55; 上面示例中，type命令为 number 类型定义了一个别名 Age。这样就能像使用 number 一样，使用 Age 作为类型。\n别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。\n别名不允许重名。\n1type Color = \u0026#39;red\u0026#39;; 2type Color = \u0026#39;blue\u0026#39;; // 报错 上面示例中，同一个别名 Color 声明了两次，就报错了。\n别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。\nTypeScript typeof 操作符 在 TypeScript 中，typeof 操作符有两种主要用途：\n获取一个表达式在运行时的类型（类似于 JavaScript 中的 typeof）。 在类型层面上查询变量或表达式的类型，以便在其他地方重用该类型（类型查询）。 运行时使用 typeof 在运行时，typeof 操作符返回一个字符串，描述了一个值的类型。这与 JavaScript 完全一致。常见的返回值包括 \u0026quot;string\u0026quot;, \u0026quot;number\u0026quot;, \u0026quot;boolean\u0026quot;, \u0026quot;undefined\u0026quot;, \u0026quot;object\u0026quot;, 和 \u0026quot;function\u0026quot;。\n例如：\n1const someValue = 42; 2 3if (typeof someValue === \u0026#34;number\u0026#34;) { 4 console.log(\u0026#34;someValue 是一个数字\u0026#34;); 5} 类型层面上的 typeof（类型查询） TypeScript 允许你在类型层面上使用 typeof 来获取一个变量或对象的类型，并将其用于类型声明中。这种用法称为“类型查询”，它可以帮助你重用已有的类型，而无需重复编写接口或类型定义。\n例如：\n1const person = { 2 name: \u0026#34;Alice\u0026#34;, 3 age: 30, 4}; 5 6// 使用 typeof person 获取 person 的类型，并创建一个类型别名 7type PersonType = typeof person; 8 9const anotherPerson: PersonType = { 10 name: \u0026#34;Bob\u0026#34;, 11 age: 25, 12}; 在这个例子中，typeof person 获取了 person 变量的类型，并创建了名为 PersonType 的类型，这样可以避免手动定义重复的类型结构。\n块级类型声明 TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。\n1if (true) { 2 type T = number; 3 let v:T = 5; 4} else { 5 type T = string; 6 let v:T = \u0026#39;hello\u0026#39;; 7} 上面示例中，存在两个代码块，其中分别有一个类型 T 的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。\n数组 使用方括号语法 最常见的方式是直接在类型后面加上方括号 [] 表示数组类型。\n1let numbers: number[] = [1, 2, 3, 4, 5]; 2let fruits: string[] = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;]; 使用泛型语法 TypeScript 提供了泛型数组语法 Array\u0026lt;元素类型\u0026gt;，其效果与方括号语法完全相同。\n1let numbers: Array\u0026lt;number\u0026gt; = [1, 2, 3, 4, 5]; 2let fruits: Array\u0026lt;string\u0026gt; = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;]; 多维数组 多维数组是数组的数组。例如，二维数组可以表示为数组中的每个元素都是一个数组。\n1let matrix: number[][] = [ 2 [1, 2], 3 [3, 4], 4 [5, 6], 5]; 6 7console.log(matrix); 8// 输出: 9// [ 10// [1, 2], 11// [3, 4], 12// [5, 6] 13// ] 元组 在 TypeScript 中，元组（Tuple）是一种特殊类型的数组，它允许你在同一个数组中存储多个不同类型的值，同时要求元素的个数和顺序固定。使用元组，能够更明确地描述混合类型数据的结构。\n定义元组 你可以使用带有固定数量和类型的元素来定义元组。例如，下面我们定义了一个包含数字和字符串的元组：\n1let user: [number, string] = [1, \u0026#34;Alice\u0026#34;]; 2 3// 正确: 按照定义提供了 number 和 string 类型的值 4console.log(user); 5 6// 错误示例: 交换顺序会导致类型错误 7// let wrongUser: [number, string] = [\u0026#34;Alice\u0026#34;, 1]; 元组的解构赋值 元组支持解构赋值，你可以直接把元组的每个元素赋值给单独的变量：\n1let user: [number, string] = [1, \u0026#34;Alice\u0026#34;]; 2let [userId, userName] = user; 3 4console.log(userId); // 输出: 1 5console.log(userName); // 输出: Alice 可选的元组元素 TypeScript 允许在元组中定义可选元素，这些可选元素必须放在元组的末尾。例如：\n1let response: [number, string?] = [200]; 2 3console.log(response); // 输出: [200] 4 5// 此外，也可以提供所有元素 6let fullResponse: [number, string?] = [200, \u0026#34;OK\u0026#34;]; 7console.log(fullResponse); // 输出: [200, \u0026#34;OK\u0026#34;] 函数类型 函数声明 通过函数声明，你可以直接在函数签名中定义参数和返回值的类型。\n1function greet(name: string): string { 2 return `Hello, ${name}!`; 3} 4 5console.log(greet(\u0026#34;Alice\u0026#34;)); 函数表达式 你也可以使用函数表达式的方式定义函数，同时为变量指定函数类型。\n1const add: (a: number, b: number) =\u0026gt; number = function (a, b) { 2 return a + b; 3}; 4 5console.log(add(2, 3)); 可选参数和默认参数 TypeScript 允许在函数中使用可选参数和默认参数，使得函数调用更灵活。\n1// 可选参数 lastName 使用 ? 标记 2function buildName(firstName: string, lastName?: string): string { 3 return lastName ? `${firstName} ${lastName}` : firstName; 4} 5 6console.log(buildName(\u0026#34;John\u0026#34;)); 7console.log(buildName(\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;)); 8 9// 默认参数 b 默认值为 2 10function multiply(a: number, b: number = 2): number { 11 return a * b; 12} 13 14console.log(multiply(5)); // 输出: 10 15console.log(multiply(5, 3)); // 输出: 15 剩余参数 当函数需要接受任意数量的参数时，可以使用剩余参数（rest parameters）。\n1function joinStrings(separator: string, ...strings: string[]): string { 2 return strings.join(separator); 3} 4 5console.log(joinStrings(\u0026#34;, \u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;)); // 输出: apple, banana, cherry 函数类型作为参数和返回值 TypeScript 可以定义函数类型，将其用作参数类型或返回值类型，从而实现高阶函数。\n1// 定义一个函数类型 Operation 2type Operation = (a: number, b: number) =\u0026gt; number; 3 4// 实现加法函数 5const add: Operation = (a, b) =\u0026gt; a + b; 6 7// 高阶函数，接收一个 Operation 类型的函数作为参数 8function calculate(a: number, b: number, op: Operation): number { 9 return op(a, b); 10} 11 12console.log(calculate(4, 5, add)); // 输出: 9 函数重载 函数重载允许同一个函数根据不同的参数类型或数量提供多种签名，从而实现多态。\n1// 函数重载的声明 2function combine(x: string, y: string): string; 3function combine(x: number, y: number): number; 4 5// 实现函数重载的函数体 6function combine(x: any, y: any): any { 7 return x + y; 8} 9 10console.log(combine(\u0026#34;Hello, \u0026#34;, \u0026#34;World!\u0026#34;)); // 输出: Hello, World! 11console.log(combine(10, 20)); // 输出: 30 对象 使用接口定义对象类型 1interface User { 2 id: number; 3 name: string; 4 email: string; 5 // 可选属性, 如果没有提供不会报错 6 age?: number; 7 // 只读属性, 一旦赋值后就不能修改 8 readonly createdAt: Date; 9} 10 11const user: User = { 12 id: 1, 13 name: \u0026#34;Alice\u0026#34;, 14 email: \u0026#34;alice@example.com\u0026#34;, 15 createdAt: new Date(), 16}; 17 18// 下面的修改将发生错误，因为 createdAt 是只读属性 19// user.createdAt = new Date(); 20console.log(user); 使用类型别名定义对象类型 1type User = { 2 id: number; 3 name: string; 4 email: string; 5 age?: number; // 可选属性 6 readonly createdAt: Date; // 只读属性 7}; 8 9const user: User = { 10 id: 2, 11 name: \u0026#34;Bob\u0026#34;, 12 email: \u0026#34;bob@example.com\u0026#34;, 13 createdAt: new Date(), 14}; 15 16console.log(user); 定义对象上的方法 除了描述属性，TypeScript 的对象类型同样可以描述方法。下面是一个例子：\n1interface User { 2 id: number; 3 name: string; 4 email: string; 5 greet(): string; 6} 7 8const user: User = { 9 id: 3, 10 name: \u0026#34;Charlie\u0026#34;, 11 email: \u0026#34;charlie@example.com\u0026#34;, 12 greet() { 13 return `Hello, my name is ${this.name}`; 14 }, 15}; 16 17console.log(user.greet()); 对象字面量的类型检查 在 TypeScript 中，当你直接使用对象字面量创建对象时，编译器会对属性的存在性和类型进行严格检查。这帮助我们发现拼写错误或遗漏的属性：\n1interface Config { 2 port: number; 3 host: string; 4} 5 6const config: Config = { 7 port: 8080, 8 host: \u0026#34;localhost\u0026#34;, 9 // 如果加上多余属性，例如 protocol: \u0026#34;http\u0026#34;，编译器将报错 10}; 11 12console.log(`Server running at http://${config.host}:${config.port}`); 使用索引签名定义动态属性的对象 当你需要定义一个包含动态属性名的对象时，可以使用索引签名。如下例子展示了如何定义一个可以包含任意字符串键及其对应值的对象：\n1interface Dictionary { 2 [key: string]: string; 3} 4 5const translations: Dictionary = { 6 hello: \u0026#34;你好\u0026#34;, 7 goodbye: \u0026#34;再见\u0026#34;, 8}; 9 10console.log(translations.hello); interface 定义基本接口 下面的示例展示了如何定义一个接口 User，描述用户对象的属性：\n1interface User { 2 id: number; 3 name: string; 4 age: number; 5 email?: string; // 可选属性，用 ? 标记 6} 7 8const user: User = { 9 id: 1, 10 name: \u0026#34;Alice\u0026#34;, 11 age: 30, 12 email: \u0026#34;alice@example.com\u0026#34;, 13}; 14 15console.log(user); 接口中的只读属性 接口可以定义只读属性，一旦对象被创建后，这些属性就不能被修改，从而增强数据的安全性。\n1interface ReadOnlyUser { 2 readonly id: number; 3 name: string; 4} 5 6const user: ReadOnlyUser = { 7 id: 100, 8 name: \u0026#34;Bob\u0026#34;, 9}; 10 11// 下面这行代码会报错，因为 id 是只读属性 12// user.id = 101; 接口中的方法 可以在接口中定义方法，这样实现接口的对象必须提供方法的具体实现。\n1interface User { 2 id: number; 3 name: string; 4 greet(message: string): string; 5} 6 7const user: User = { 8 id: 2, 9 name: \u0026#34;Charlie\u0026#34;, 10 greet(message: string) { 11 return `Hello ${this.name}, ${message}`; 12 }, 13}; 14 15console.log(user.greet(\u0026#34;welcome!\u0026#34;)); 接口的嵌套和继承 接口不仅可以描述简单对象，还可以通过嵌套和继承来构建更复杂的类型结构。\n1interface Person { 2 name: string; 3 age: number; 4} 5 6interface Employee extends Person { 7 employeeId: number; 8 department: string; 9} 10 11const employee: Employee = { 12 name: \u0026#34;David\u0026#34;, 13 age: 28, 14 employeeId: 12345, 15 department: \u0026#34;Engineering\u0026#34;, 16}; 17 18console.log(employee); 使用接口描述函数类型 接口同样可以用来描述函数类型，这样可以明确函数的参数和返回值类型，提高代码的可读性和稳定性。\n1interface Comparator { 2 (a: number, b: number): number; 3} 4 5const compare: Comparator = (x, y) =\u0026gt; { 6 if (x \u0026lt; y) return -1; 7 if (x \u0026gt; y) return 1; 8 return 0; 9}; 10 11console.log(compare(3, 5)); ","date":"2025-02-18T20:20:09+08:00","permalink":"https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etypescript%E7%9A%84%E7%AC%94%E8%AE%B0/","title":"关于TypeScript的笔记"},{"content":"前言 在前端开发中，CSS（层叠样式表）是一门非常重要的语言，它控制着网页的视觉呈现效果。作为前端三大基础技术（HTML、CSS、JavaScript）之一，掌握 CSS 对于构建优美的用户界面至关重要。\n希望这些笔记不仅能帮助自己梳理知识体系，也能为其他学习 CSS 的朋友提供参考。\nPS 不定时更新，欢迎讨论区留言。\nCSS 选择器及其优先级 优先级权重表 选择器类型 权重值 示例 说明 !important ∞ color: red !important; 最高优先级 行内样式 1,0,0,0 \u0026lt;div style=\u0026quot;...\u0026quot;\u0026gt; 直接在标签上的样式 ID 选择器 0,1,0,0 #header 以#开头的选择器 类/伪类/属性 0,0,1,0 .class :hover [type=\u0026quot;text\u0026quot;] 类、伪类、属性选择器 元素/伪元素 0,0,0,1 div ::before 标签选择器和伪元素 通配符 0,0,0,0 * 最低优先级 常用选择器示例表 选择器类型 语法 示例 说明 通配符 * * { margin: 0; } 选择所有元素 元素选择器 element p { color: blue; } 选择指定标签 类选择器 .class .active { color: red; } 选择指定类名 ID 选择器 #id #header { height: 60px; } 选择指定 ID 属性选择器 [attribute] [type=\u0026quot;text\u0026quot;] { border: 1px solid; } 选择带有特定属性的元素 组合选择器表 组合方式 语法 示例 优先级计算 后代选择器 A B .nav a { color: blue; } 累加(0,0,1,1) 子选择器 A \u0026gt; B .nav \u0026gt; a { color: red; } 累加(0,0,1,1) 相邻兄弟 A + B h2 + p { margin: 10px; } 累加(0,0,0,2) 通用兄弟 A ~ B h2 ~ p { color: gray; } 累加(0,0,0,2) 伪类和伪元素表 类型 示例 优先级 说明 伪类 :hover 0,0,1,0 特定状态的样式 伪类 :first-child 0,0,1,0 位置相关的样式 伪元素 ::before 0,0,0,1 创建额外的元素 伪元素 ::first-line 0,0,0,1 特殊的文本样式 复杂选择器优先级计算表 选择器 计算方式 最终优先级 说明 .header.active (0,0,1,0) + (0,0,1,0) 0,0,2,0 多类选择器 #nav .list li (0,1,0,0) + (0,0,1,0) + (0,0,0,1) 0,1,1,1 ID+类+元素 .nav a:hover (0,0,1,0) + (0,0,0,1) + (0,0,1,0) 0,0,2,1 类+元素+伪类 flex CSS Flexbox（弹性盒布局）是一种用于在容器内分布空间以及对齐内容的布局模式。它提供了一种更高效的方式来排列、对齐和分布容器内的项目，即使在复杂的应用或大型屏幕设备上也能很好地工作。\n容器（Flex Container）：使用 display: flex; 或 display: inline-flex; 声明的元素，其所有直接子元素都将成为 flex 项目。 项目（Flex Items）：在 flex 容器内的直接子元素。 容器属性 display\ndisplay: flex;：将元素设为块级 flex 容器。 display: inline-flex;：将元素设为内联级 flex 容器。 flex-direction\n定义主轴的方向，决定项目的排列方向： row（默认）：水平方向，从左到右。 row-reverse：水平方向，从右到左。 column：垂直方向，从上到下。 column-reverse：垂直方向，从下到上。 flex-wrap\n定义当项目总尺寸超出容器时是否换行： nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 justify-content\n定义在主轴上的对齐方式： flex-start（默认）：左对齐或起点对齐。 flex-end：右对齐或结束对齐。 center：居中对齐。 space-between：两端对齐，项目之间的间隔相等。 space-around：项目两侧的间隔相等。 align-items\n定义在交叉轴（与主轴垂直方向）的对齐方式： stretch（默认）：拉伸填充容器。 flex-start：交叉轴起点对齐。 flex-end：交叉轴结束对齐。 center：居中对齐。 baseline：以项目的第一行文字基线对齐。 align-content\n定义多行对齐方式（当项目换行时）： stretch（默认）：各行拉伸到占满容器。 flex-start：各行顶端对齐。 flex-end：各行底端对齐。 center：居中对齐。 space-between：行与行之间间隔相等。 space-around：行之间的间隔相等。 项目属性 flex-grow\n定义项目的放大比例。如果空间充裕，flex 项目可以根据它的增长因子扩展。 flex-shrink\n定义项目的缩小比例。当空间不足时，flex 项目可以根据它的缩小因子收缩。 flex-basis\n定义在分配多余空间之前，项目占据的主轴空间。可以设置为固定值（例如 200px）也可以设置为 auto。 flex\nflex 属性是 flex-grow、flex-shrink 和 flex-basis 的简写形式。常用写法如：flex: 1; 表示 flex-grow: 1; flex-shrink: 1; flex-basis: 0%;。 align-self\n允许单个项目有不同于其他项目的对齐方式，可以覆盖容器的 align-items 属性。 取值：auto（默认）、flex-start、flex-end、center、baseline、stretch。 Grid CSS Grid 布局是一种基于网格的二维布局系统，用于创建复杂和响应式的网页布局。与 Flexbox 不同，CSS Grid 能够同时处理行和列，使其成为构建整体页面布局的强大工具。\n容器（Grid Container）： 使用 display: grid; 或 display: inline-grid; 声明的元素。其所有直接子元素将自动成为网格项目，并根据指定的网格定义进行排列。 项目（Grid Items）： Grid 容器内的直接子元素，每个项目在网格中按照指定的位置排布。 网格线（Grid Lines）： 网格中的水平和垂直分隔线，用来分割行和列。 网格单元（Grid Cell）： 两条相邻的网格线之间形成的区域，类似于表格中的单元格。 网格区域（Grid Area）： 由一个或多个网格单元组成的区域，可为网格项目命名以便布局控制。 容器属性 display: 声明一个元素为 Grid 容器。\ndisplay: grid; 用于块级 Grid 容器。 display: inline-grid; 用于内联级 Grid 容器。 grid-template-columns: 定义网格的列。可以使用固定长度、百分比、fr 单位或者 repeat() 函数来指定列的布局。\n示例： 1grid-template-columns: 200px 1fr 2fr; 或者： 1grid-template-columns: repeat(3, 1fr); grid-template-rows: 定义网格的行，写法和 grid-template-columns 类似。\n示例： 1grid-template-rows: 100px auto; gap (或 grid-gap): 定义网格行和列之间的间隙。\n示例： 1gap: 10px; grid-template-areas: 定义命名网格区域，使布局更加具语义化。\n示例： 1grid-template-areas: 2 \u0026#34;header header\u0026#34; 3 \u0026#34;sidebar content\u0026#34; 4 \u0026#34;footer footer\u0026#34;; justify-items \u0026amp; align-items: 分别设置网格项目在各自网格单元内的水平和垂直对齐方式。\n示例： 1justify-items: center; /* 水平居中 */ 2align-items: center; /* 垂直居中 */ justify-content \u0026amp; align-content: 设置整个网格在容器内的对齐方式，适用于有多余空间的情况。\n示例： 1justify-content: space-around; 2align-content: center; 项目属性 grid-column \u0026amp; grid-row: 定义项目在网格中所占据的列和行范围。可以使用网格线编号或命名区域。\n示例： 1grid-column: 1 / 3; 2grid-row: 2 / 4; grid-area: 用于将项目放置在命名的网格区域内，通常与 grid-template-areas 配合使用。\n示例： 1grid-area: header; ","date":"2025-02-15T16:35:09+08:00","permalink":"https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ecss%E7%9A%84%E7%AC%94%E8%AE%B0/","title":"关于CSS的笔记"},{"content":"为什么要搭建个人博客 很早就有搭建个人博客的想法，主要是想有一个属于自己的空间，可以记录学习笔记、分享经验和想法。经过一段时间的准备，终于开始实践这个计划了。\n希望通过写博客的方式，能够督促自己持续学习和思考。也欢迎大家多多交流指教！\n测试\n1 highlights.forEach(highlight =\u0026gt; { 2 const copyButton = document.createElement(\u0026#39;button\u0026#39;); 3 copyButton.innerHTML = copyText; 4 copyButton.classList.add(\u0026#39;copyCodeButton\u0026#39;); 5 highlight.appendChild(copyButton); 6 7 const codeBlock = highlight.querySelector(\u0026#39;code[data-lang]\u0026#39;); 8 if (!codeBlock) return; 9 10 copyButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { 11 // 创建一个临时容器来克隆代码块的内容 12 const tempCodeBlock = codeBlock.cloneNode(true) as HTMLElement; 13 14 // 删除行号，行号的元素是 \u0026lt;span class=\u0026#34;ln\u0026#34;\u0026gt; 15 const lineNumbers = tempCodeBlock.querySelectorAll(\u0026#39;.ln\u0026#39;); 16 lineNumbers.forEach(lineNumber =\u0026gt; lineNumber.remove()); 17 18 // 获取没有行号的纯文本内容 19 const codeText = tempCodeBlock.textContent; 20 21 navigator.clipboard.writeText(codeText || \u0026#39;\u0026#39;) 22 // navigator.clipboard.writeText(codeBlock.textContent) 23 .then(() =\u0026gt; { 24 copyButton.textContent = copiedText; 25 26 setTimeout(() =\u0026gt; { 27 copyButton.textContent = copyText; 28 }, 1000); 29 }) 30 .catch(err =\u0026gt; { 31 alert(err) 32 console.log(\u0026#39;Something went wrong\u0026#39;, err); 33 }); 34 }); 35 }); ","date":"2025-02-08T19:54:09+08:00","permalink":"https://blog.ltlyl.fun/p/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99-blog/","title":"第一次写 blog"}]