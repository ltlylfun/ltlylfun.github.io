<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这是ltlylfun的blog网站，分享技术与生活"><meta name=keywords content="TCP,UDP,笔记"><title>关于TCP/UDP的笔记 | ltlylfunBlog
</title><link rel=canonical href=https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/><link rel=stylesheet href=/scss/style.min.5ec82771aeed1210f68866fcc97744d75ca389311d988f5446c0f985a65f1c13.css><meta property='og:title' content="关于TCP/UDP的笔记"><meta property='og:description' content="记录一些TCP/UDP笔记"><meta property='og:url' content='https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/'><meta property='og:site_name' content='ltlylfunBlog'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='计算机网络'><meta property='article:tag' content='TCP/UDP'><meta property='article:published_time' content='2025-02-20T16:16:09+08:00'><meta property='article:modified_time' content='2025-02-20T16:16:09+08:00'><meta name=twitter:title content="关于TCP/UDP的笔记"><meta name=twitter:description content="记录一些TCP/UDP笔记"><link rel="shortcut icon" href=/favicon.jpg><script async src="https://www.googletagmanager.com/gtag/js?id=G-8LR72PVL5E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8LR72PVL5E")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/Ukenn2112/UkennWeb@3.0/index/web.js></script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/touxiang_hu_ced73ba41416a34a.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>ltlylfunBlog</a></h1><h2 class=site-description>流动的水没有形状，漂流的风找不到踪迹。</h2></div></header><ol class=menu-social><li><a href=https://github.com/ltlylfun target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#前言>前言</a></li><li><a href=#什么是-tcp>什么是 TCP？</a></li><li><a href=#tcp-与-udp-对比表>TCP 与 UDP 对比表</a></li><li><a href=#tcp-和-udp-可以使同个端吗>TCP 和 UDP 可以使⽤同⼀个端⼝吗？</a></li><li><a href=#序列号seq和初始序列号isn>序列号(SEQ)和初始序列号(ISN)</a></li><li><a href=#tcp-三次握手过程>TCP 三次握手过程</a></li><li><a href=#为什么需要三次握手而不是两次或四次>为什么需要三次握手，而不是两次或四次？</a></li><li><a href=#tcp-握手丢失情况>TCP 握手丢失情况</a><ol><li><a href=#tcp-第一次握手丢失的情况>TCP 第一次握手丢失的情况</a></li><li><a href=#tcp-第二次握手丢失的情况>TCP 第二次握手丢失的情况</a></li><li><a href=#tcp-第三次握手丢失的情况>TCP 第三次握手丢失的情况</a></li></ol></li><li><a href=#tcp-四次挥手过程>TCP 四次挥手过程</a></li><li><a href=#为什么-tcp-挥手需要四次>为什么 TCP 挥手需要四次？</a></li><li><a href=#什么情况会出现三次挥手>什么情况会出现三次挥手？</a></li><li><a href=#tcp-挥手丢失情况>TCP 挥手丢失情况</a><ol><li><a href=#tcp-第一次挥手丢失的情况>TCP 第一次挥手丢失的情况</a></li><li><a href=#tcp-第二次挥手丢失的情况>TCP 第二次挥手丢失的情况</a></li><li><a href=#tcp-第三次挥手丢失的情况>TCP 第三次挥手丢失的情况</a></li><li><a href=#tcp-第四次挥手丢失的情况>TCP 第四次挥手丢失的情况</a></li></ol></li><li><a href=#为什么需要-time_wait-状态>为什么需要 TIME_WAIT 状态？</a></li><li><a href=#为什么每次建立-tcp-连接时初始化的序列号都要求不一样>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样？</a></li><li><a href=#什么是-mtu>什么是 MTU</a></li><li><a href=#什么是-mss>什么是 MSS？</a></li><li><a href=#为什么-tcp-层需要-mss>为什么 TCP 层需要 MSS？</a></li><li><a href=#tcp-的粘包拆包以及解决方案>TCP 的粘包、拆包以及解决方案</a><ol><li><a href=#什么是粘包>什么是粘包？</a></li><li><a href=#为什么-udp-没有粘包>为什么 UDP 没有粘包？</a></li><li><a href=#粘包拆包发生场景>粘包拆包发生场景</a></li><li><a href=#常见的解决方案>常见的解决方案</a></li></ol></li><li><a href=#重传机制>重传机制</a><ol><li><a href=#超时重传以时间驱动>超时重传（以时间驱动）</a></li><li><a href=#快速重传以数据驱动>快速重传（以数据驱动）</a></li><li><a href=#sack-方法>SACK 方法</a></li><li><a href=#duplicate-sack-方法>Duplicate SACK 方法</a></li></ol></li><li><a href=#滑动窗口>滑动窗口</a></li><li><a href=#流量控制>流量控制</a></li><li><a href=#拥塞控制>拥塞控制</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ style=background-color:#2a9d8f;color:#fff>计算机网络</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/>关于TCP/UDP的笔记</a></h2><h3 class=article-subtitle>记录一些TCP/UDP笔记</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 20, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 14 分钟</time></div></footer></div></header><section class=article-content><h2 id=前言>前言</h2><p>关于 TCP/UDP 的笔记。</p><p>希望这些笔记不仅能帮助自己系统梳理知识，也能为其他学习计算机网络的朋友提供借鉴。</p><p>PS 不定时更新，欢迎讨论区留言。</p><h2 id=什么是-tcp>什么是 TCP？</h2><p>TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。</p><ol><li><p><strong>面向连接</strong><br>在发送数据之前，通信双方会先通过一个称为“三次握手”（3-way handshake）的过程建立一条可靠的传输连接。只有连接建立完成后，数据传输才能开始。是一对一的，不能像 UDP 一样一对多。</p></li><li><p><strong>可靠传输</strong><br>TCP 使用数据确认（ACK）、超时重传、重复确认（Duplicate ACK）等机制，确保数据包能够按顺序、完整地到达接收端。如果发生数据丢失或出错，TCP 能够自动进行重传，保证传输的可靠性。</p></li><li><p><strong>面向字节流</strong><br>TCP 将数据视为连续的字节流，而不是独立的数据包。这意味着在应用层数据的边界需要进行额外管理，例如通过消息分隔符或固定长度来标识每个独立的消息。</p></li></ol><h2 id=tcp-与-udp-对比表>TCP 与 UDP 对比表</h2><div class=table-wrapper><table><thead><tr><th><strong>方面</strong></th><th><strong>TCP</strong></th><th><strong>UDP</strong></th></tr></thead><tbody><tr><td>面向连接</td><td>是，需要建立连接（三次握手）后才能进行数据传输</td><td>否，无连接，数据直接发送</td></tr><tr><td>数据可靠性</td><td>高，具备数据确认、重传机制、累积确认和错误校验等措施，确保数据准确无误到达</td><td>低，无内建确认和重传机制，数据可能丢失或乱序</td></tr><tr><td>数据顺序</td><td>保证按发送顺序到达</td><td>不保证顺序，数据包独立传输</td></tr><tr><td>流量控制</td><td>采用滑动窗口机制，根据接收方缓冲区大小动态控制数据发送速率</td><td>无，发送数据完全由应用层控制，可能导致接收端被淹没</td></tr><tr><td>拥塞控制</td><td>有，使用慢启动、拥塞避免、快速重传与快速恢复等算法，动态调整发送速率以应对网络拥塞</td><td>无，不具备拥塞控制，可能在网络繁忙时频繁丢包</td></tr><tr><td>错误检测与恢复</td><td>有，通过校验和及确认机制检测错误，并通过重传恢复丢失的数据</td><td>仅有基本的校验和，不能进行错误恢复</td></tr><tr><td>头部开销</td><td>较大，TCP 头部通常为 20 字节或以上，包含丰富的控制信息</td><td>较小，仅 8 字节，结构简单</td></tr><tr><td>连接管理</td><td>复杂，需经过三次握手建立连接及四次挥手断开连接，带来额外延时和资源开销</td><td>简单，无需连接建立和断开，适用于快速传输</td></tr><tr><td>实时性</td><td>相对较低，其可靠性保障和拥塞控制可能导致延迟上升，通常不适用于对延迟极度敏感的场景</td><td>高，延迟低，适合实时视频、在线游戏、VoIP 等对时效性要求较高的应用</td></tr><tr><td>适用场景</td><td>文件传输、网页浏览、电子邮件、数据库通信等需要高可靠性和数据顺序保证的应用</td><td>实时通讯、视频会议、在线游戏、DNS 查询、流媒体传输等可以容忍部分数据丢失，但要求低延迟的场景</td></tr></tbody></table></div><h2 id=tcp-和-udp-可以使同个端吗>TCP 和 UDP 可以使⽤同⼀个端⼝吗？</h2><p>可以的。</p><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p><p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p><p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><h2 id=序列号seq和初始序列号isn>序列号(SEQ)和初始序列号(ISN)</h2><p>序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP
是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋
予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32
位的无符号数，因此在到达 4G 之后再循环回到 0。</p><p>初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时
钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位
的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。</p><h2 id=tcp-三次握手过程>TCP 三次握手过程</h2><p>TCP 三次握手（Three-Way Handshake）是建立一个可靠的 TCP 连接的过程，通过交换控制信息来初始化连接参数。下面是详细的步骤：</p><ol><li><p><strong>第一次握手（SYN）</strong></p><ul><li>客户端向服务器发送一个带有 SYN 标志的报文段，该报文段包含客户端选择的初始序列号（ISN）。</li><li>该报文段表示客户端希望与服务器建立连接。</li><li>表示形式：<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>客户端 → 服务器: SYN, Seq = x
</span></span></code></pre></div></li></ul></li><li><p><strong>第二次握手（SYN-ACK）</strong></p><ul><li>服务器收到客户端的 SYN 后，发送一个包含 SYN 和 ACK 标志的报文段给客户端。</li><li>该报文段中，ACK 用来确认收到客户端的 SYN（Ack = x + 1），同时服务器也选择一个初始序列号（ISN = y）来建立自己的连接参数。</li><li>表示形式：<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>服务器 → 客户端: SYN, ACK, Seq = y, Ack = x + 1
</span></span></code></pre></div></li></ul></li><li><p><strong>第三次握手（ACK）</strong></p><ul><li>客户端在收到服务器的 SYN-ACK 后，再发送一个只带 ACK 标志的报文段，作为对服务器响应的确认。</li><li>该报文段中的 ACK 用来确认收到服务器的 SYN（Ack = y + 1）。</li><li>表示形式：<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>客户端 → 服务器: ACK, Seq = x + 1, Ack = y + 1
</span></span></code></pre></div></li></ul></li></ol><p>当服务器收到这个 ACK 后，双方就建立了一个可靠的 TCP 连接，可以进行后续数据传输了。</p><h2 id=为什么需要三次握手而不是两次或四次>为什么需要三次握手，而不是两次或四次？</h2><p>「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双方资源的浪费，也⽆法可靠的同步双⽅序列号。</p><p>「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。</p><h2 id=tcp-握手丢失情况>TCP 握手丢失情况</h2><h3 id=tcp-第一次握手丢失的情况>TCP 第一次握手丢失的情况</h3><p>当第一次握手丢失时，TCP 将通过重传策略来尝试恢复连接，但如果问题持续存在，连接将建立失败并反馈错误信息给应用程序。</p><h3 id=tcp-第二次握手丢失的情况>TCP 第二次握手丢失的情况</h3><p>当第二次握手丢失了，客户端和服务端都会重传。</p><ul><li><p>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由内核参数决定。</p></li><li><p>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由内核参数决定。</p></li></ul><h3 id=tcp-第三次握手丢失的情况>TCP 第三次握手丢失的情况</h3><p>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。直到收到第三次握⼿，或者达到最⼤重传次数。</p><h2 id=tcp-四次挥手过程>TCP 四次挥手过程</h2><ol><li><p><strong>第一次挥手（FIN）</strong></p><ul><li>客户端在没有数据发送后，向服务器发送一个带有 FIN 标志的报文段，以指示客户端不再有数据要发送。</li><li>表示形式：<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>客户端 → 服务器: FIN, Seq = u
</span></span></code></pre></div></li></ul></li><li><p><strong>第二次挥手（ACK）</strong></p><ul><li>服务器收到客户端的 FIN 报文段后，立即发送一个 ACK 报文段作为确认，表明已接收到客户端停止发送数据的请求。</li><li>表示形式：<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>服务器 → 客户端: ACK, Seq = v, Ack = u + 1
</span></span></code></pre></div></li><li>此时，服务器可能仍有未传输完的数据，故数据传输方向上尚未完全关闭。</li></ul></li><li><p><strong>第三次挥手（FIN）</strong></p><ul><li>当服务器完成剩余数据的传输后，会向客户端发送一个带有 FIN 标志的报文段，通知客户端服务器也没有数据要发送了，准备关闭连接。</li><li>表示形式：<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>服务器 → 客户端: FIN, Seq = w
</span></span></code></pre></div></li></ul></li><li><p><strong>第四次挥手（ACK）</strong></p><ul><li>客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段以确认收到服务器关闭连接的请求。</li><li>表示形式：<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>客户端 → 服务器: ACK, Seq = u + 1, Ack = w + 1
</span></span></code></pre></div></li></ul></li></ol><h2 id=为什么-tcp-挥手需要四次>为什么 TCP 挥手需要四次？</h2><p>TCP 使用四次挥手断开连接，主要原因在于 TCP 连接是全双工的，也就是数据传输在两个方向上是独立的。在断开连接时，每个方向的数据传输都需要单独关闭。下面详细解释这一过程以及四次挥手的必要性：</p><ol><li><p><strong>单向关闭</strong></p><ul><li>当一方准备结束数据发送时，它只关闭自己的发送通道，但仍可接收数据。</li><li>例如，当客户端发送一个 FIN 时，它表示自己没有数据要发送了，但仍然可以接收服务器的数据。</li></ul></li><li><p><strong>独立的确认</strong></p><ul><li>对于第一次 FIN（例如客户端发送的 FIN），服务器需要发送一个 ACK 来确认已经收到关闭请求。这只是对单个方向（客户端到服务器）的关闭确认。</li><li>接下来，服务器完成自身数据发送后，也需要发送 FIN 来关闭其发送通道，客户端再对其进行确认。</li></ul></li><li><p><strong>为何需要四次</strong></p><ul><li>第一步（客户端 FIN）：客户端通知服务器“我已经没有数据要发送了”。</li><li>第二步（服务器 ACK）：服务器确认客户端的 FIN，并告知已接收，但此时仍可继续发送数据给客户端。</li><li>第三步（服务器 FIN）：当服务器也结束发送数据后，它通知客户端“我也没有数据要发送了”。</li><li>第四步（客户端 ACK）：客户端确认服务器的关闭请求，整个连接才能完全关闭。</li></ul></li><li><p><strong>可靠的连接终止</strong></p><ul><li>四次挥手确保了双方在断开连接前都能完成数据传输与确认，避免数据丢失。</li><li>这种设计使得双方可以独立地结束各自的数据传输，从而达到安全、可靠地断开连接的目的。</li></ul></li></ol><h2 id=什么情况会出现三次挥手>什么情况会出现三次挥手？</h2><p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK(默认情
况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制)」，那么第二和第三
次挥手就会合并传输，这样就出现了三次挥手。</p><h2 id=tcp-挥手丢失情况>TCP 挥手丢失情况</h2><h3 id=tcp-第一次挥手丢失的情况>TCP 第一次挥手丢失的情况</h3><p>当 TCP 第一次挥手的 FIN 报文丢失时，连接不会被立即关闭。主动关闭方会依赖重传机制来确保 FIN 最终传达到对方，一旦双方完成重传和确认，连接才会进入正常的终止流程。</p><h3 id=tcp-第二次挥手丢失的情况>TCP 第二次挥手丢失的情况</h3><p>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p><h3 id=tcp-第三次挥手丢失的情况>TCP 第三次挥手丢失的情况</h3><p>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。</p><p>客户端因为是通过 close 函数关闭连接的，处于 FIN WAIT 2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手(FIN 报文)，那么客户端就会断开连接。</p><h3 id=tcp-第四次挥手丢失的情况>TCP 第四次挥手丢失的情况</h3><p>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2，达到了最大重传次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。</p><p>客户端在收到第三次挥手后，就会进入 TIME WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手(FIN 报文)后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</p><h2 id=为什么需要-time_wait-状态>为什么需要 TIME_WAIT 状态？</h2><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收。</p><p>保证「被动关闭连接」的一方，能被正确的关闭。</p><h2 id=为什么每次建立-tcp-连接时初始化的序列号都要求不一样>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样？</h2><ol><li><p><strong>防止旧数据干扰</strong><br>如果使用固定或者可预测的序列号，网络中可能还残留有上一次连接的数据包，在新连接建立后，这些旧数据包可能会被误认为是当前连接的数据，从而导致数据混乱或连接异常。选择唯一的 ISN 可以避免这种数据干扰问题。</p></li><li><p><strong>确保数据流正确排序</strong><br>TCP 是一个面向字节流的协议，双方通过序列号来组织和排序数据。当每次连接的序列号都不相同时，可以确保即使出现重传或者网络延迟，接收方也能正确地将数据包按正确的顺序进行排序和重组。</p></li><li><p><strong>增强安全性</strong><br>可预测的序列号可能给攻击者提供利用的机会，例如 TCP 序列号预测攻击。因此，每次连接都使用一个不容易预测的初始序列号，可以有效提升连接的安全性，降低恶意攻击的风险。</p></li><li><p><strong>区分不同连接</strong><br>在同一对主机之间可能会在短时间内建立多个 TCP 连接。通过为每个连接选择不同的 ISN，可以帮助系统区分并管理这些连接，防止连接状态混淆。</p></li></ol><h2 id=什么是-mtu>什么是 MTU</h2><p>最大传输单元（英语：Maximum Transmission Unit，缩写 MTU）是指数据链路层上面所能通过的最大数据包大小（以字节为单位）。</p><h2 id=什么是-mss>什么是 MSS？</h2><p>最大分段大小（Maximum Segment Size）是传输控制协议的一个参数，以字节数定义一个计算机或通信设备所能接受的分段的最大数据量。 它并不会计算 TCP 或 IP 协议头的大小。即最大传输单元除去信头后的最大数据量。</p><h2 id=为什么-tcp-层需要-mss>为什么 TCP 层需要 MSS？</h2><ol><li><p><strong>降低 IP 分片的开销和风险</strong></p><ul><li><strong>分片开销</strong>：IP 分片不仅增加了每个数据包在网络上传输时的负担，还会影响路由器和接收主机的处理效率。每个分片都需要单独处理，如果分片过多，会导致额外的延时和资源消耗。</li><li><strong>分片丢失问题</strong>：如果 IP 分片中的任一碎片丢失，整个数据包都必须重新传输。而且某些网络设备可能不支持 IP 分片或安全策略会丢弃分片，导致传输失败。</li></ul></li><li><p><strong>提高传输效率与可靠性</strong></p><ul><li><strong>匹配底层网络 MTU</strong>：TCP 在连接建立时协商并计算对端的 MSS，通常依据路径 MTU（Path MTU）来计算。这样可以确保 TCP 报文段在封装进 IP 数据报之后，不会超出最低链路的 MTU，从而避免触发 IP 分片。</li><li><strong>优化数据传输</strong>：合理的 MSS 可以使得每个 TCP 报文段刚好适应底层网络的 MTU，最大限度地利用网络带宽，确保传输的连续性和高效性。</li></ul></li><li><p><strong>简化错误处理</strong></p><ul><li>使用 MSS 限制 TCP 报文段大小可以降低由于 IP 分片引起的重传和错误处理的复杂度。如果发生数据丢失，整个 TCP 报文段丢失时，只需要重传一个比较小的单元，而不是一个由多个分片组成的大数据包。</li></ul></li><li><p><strong>协商与兼容性</strong></p><ul><li>在 TCP 三次握手过程中，双方会交换 MSS 值，明确双方所能接受的最大报文段大小。这种协商有助于两端在一个共同的限制下进行通信，从而确保数据传输更加稳定和兼容不同网络环境。</li></ul></li></ol><h2 id=tcp-的粘包拆包以及解决方案>TCP 的粘包、拆包以及解决方案</h2><p><img src=/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.jpeg width=1568 height=1182 srcset="/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85_hu_59cd60b8110afc0d.jpeg 480w, /p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85_hu_2c3837d336d7b176.jpeg 1024w" loading=lazy alt=粘包拆包 class=gallery-image data-flex-grow=132 data-flex-basis=318px></p><p>上图中演示了以下几种情况：</p><ul><li>正常的理想情况，两个包恰好满足 TCP 缓冲区的大小或达到 TCP 等待时长，分别发送两个包；</li><li>粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；</li><li>拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；</li><li>拆包和粘包：Packet1 过大，进行了拆包处理，而拆出去的一部分又与 Packet2 进行粘包处理。</li></ul><h3 id=什么是粘包>什么是粘包？</h3><p>指 TCP 协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p>TCP 是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。</p><h3 id=为什么-udp-没有粘包>为什么 UDP 没有粘包？</h3><p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于 UDP 有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在 TCP 协议中。</p><h3 id=粘包拆包发生场景>粘包拆包发生场景</h3><p>因为 TCP 是面向流，没有边界，而操作系统在发送 TCP 数据时，会通过缓冲区来进行优化，例如缓冲区为 1024 个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包。</p><h3 id=常见的解决方案>常见的解决方案</h3><ul><li>发送端将每个包都封装成固定的长度，比如 100 字节大小。如果不足 100 字节可通过补 0 或空等进行填充到指定长度；</li><li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n 进行合并；例如，FTP 协议；</li><li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li><li>通过自定义协议进行粘包和拆包的处理。</li></ul><h2 id=重传机制>重传机制</h2><h3 id=超时重传以时间驱动>超时重传（以时间驱动）</h3><p>RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。</p><p>超时重传时间是以 RTO(Retransmission Timeout 超时重传时间)表示。</p><p>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差。</p><p>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</p><p>根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</p><h3 id=快速重传以数据驱动>快速重传（以数据驱动）</h3><p>发送方发出了 1，2，3，4，5 份数据:
第一份 Seq1 先送到了，于是就 Ack 回 2;结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2;后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2 因为 Seq2 还是没有收到。</p><p>发送端收到了三个 Ack =2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</p><p>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6。</p><p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。</p><h3 id=sack-方法>SACK 方法</h3><p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p><h3 id=duplicate-sack-方法>Duplicate SACK 方法</h3><p>Duplicate SACK 又称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</p><h2 id=滑动窗口>滑动窗口</h2><p>TCP 滑动窗口是一种流量控制机制，用于管理在发送端和接收端之间传输的数据量，其基本原理如下：</p><ol><li><p><strong>发送窗口</strong></p><ul><li>发送端维护一个窗口，表示允许发送但尚未收到确认的数据范围。</li></ul></li><li><p><strong>接收窗口</strong></p><ul><li>接收端根据自身缓冲区大小，通过 ACK 报文告知发送端当前可接收的数据量，这就是接收窗口。</li></ul></li><li><p><strong>窗口滑动</strong></p><ul><li>当发送端收到 ACK 确认后，窗口向前移动，释放已确认的数据位置，从而可以继续发送新的数据。</li><li>这种“滑动”过程确保了数据的连续传输，同时防止发送端发送过多数据导致接收端溢出。</li></ul></li></ol><h2 id=流量控制>流量控制</h2><p>TCP 流量控制是一种确保数据传输双方保持平衡的机制。其主要目标是：</p><ul><li><strong>保护接收端</strong>：避免发送速率超过接收端处理能力，防止数据丢失或缓冲区溢出。</li><li><strong>动态调整数据流</strong>：通过接收端反馈的窗口大小，发送端能够动态决定一次可以发送多少数据，确保高效且稳定的数据传输。</li></ul><p>简单来说，TCP 流量控制就是通过交换窗口大小信息，使发送方根据接收方的当前处理能力来决定发送数据的速率，从而保持整个数据传输过程的可靠性和高效性。</p><h2 id=拥塞控制>拥塞控制</h2><p>TCP 拥塞控制是一种确保网络稳定和高效的数据传输机制，其主要目标是：</p><ul><li><strong>预防网络拥塞</strong>：通过检测数据包丢失、延迟增大等现象，判断网络是否发生拥堵。</li><li><strong>动态调整发送速率</strong>：在网络出现拥堵迹象时，降低发送窗口大小或发送速率；当网络状况改善时，逐步增加速率。</li><li><strong>维护传输效率</strong>：在避免网络拥堵的同时，尽可能利用可用带宽实现高效的数据传输。</li></ul><p>简单来说，TCP 拥塞控制就是通过动态调整数据发送速率来应对网络拥堵，确保数据传输既稳定又高效。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a>
<a href=/tags/tcp/udp/>TCP/UDP</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/%E5%85%B3%E4%BA%8Ehttp/https%E7%9A%84%E7%AC%94%E8%AE%B0/><div class=article-details><h2 class=article-title>关于HTTP/HTTPS的笔记</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=ltlylfun/ltlylfun.github.io data-repo-id=R_kgDON2LRBA data-category=Announcements data-category-id=DIC_kwDON2LRBM4CmxiY data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"noborder_gray")}})()</script><footer class=site-footer><section class=copyright>&copy; 2020 - 2025 ltlylfunBlog</section><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.9eeb07c2996c35aae0e3e395e84530721297b213ef2a895edacbc42c59b09844.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>let s1="2025-2-08";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script></body></html>