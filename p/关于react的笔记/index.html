<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="这是ltlylfun的blog网站，分享技术与生活"><meta name=keywords content="React"><title>关于React的笔记 | ltlylfunBlog
</title><link rel=canonical href=https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ereact%E7%9A%84%E7%AC%94%E8%AE%B0/><link rel=stylesheet href=/scss/style.min.5ec82771aeed1210f68866fcc97744d75ca389311d988f5446c0f985a65f1c13.css><meta property='og:title' content="关于React的笔记"><meta property='og:description' content="记录一些React笔记"><meta property='og:url' content='https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ereact%E7%9A%84%E7%AC%94%E8%AE%B0/'><meta property='og:site_name' content='ltlylfunBlog'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='React'><meta property='article:published_time' content='2025-02-22T14:20:09+08:00'><meta property='article:modified_time' content='2025-02-22T14:20:09+08:00'><meta name=twitter:title content="关于React的笔记"><meta name=twitter:description content="记录一些React笔记"><link rel="shortcut icon" href=/favicon.jpg><script async src="https://www.googletagmanager.com/gtag/js?id=G-8LR72PVL5E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8LR72PVL5E")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/Ukenn2112/UkennWeb@3.0/index/web.js></script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/touxiang_hu_ced73ba41416a34a.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>ltlylfunBlog</a></h1><h2 class=site-description>流动的水没有形状，漂流的风找不到踪迹。</h2></div></header><ol class=menu-social><li><a href=https://github.com/ltlylfun target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#前言>前言</a></li><li><a href=#react-组件名称>React 组件名称</a></li><li><a href=#jsx-的规则>jsx 的规则</a><ol><li><a href=#jsx-的-return>jsx 的 return</a></li><li><a href=#标签必须闭合>标签必须闭合</a></li><li><a href=#使用驼峰式命名法给-所有-大部分属性命名>使用驼峰式命名法给 所有 大部分属性命名！</a></li></ol></li><li><a href=#默认导出与具名导出>默认导出与具名导出</a></li><li><a href=#在大括号---中使用-javascript>在大括号 { } 中使用 JavaScript</a><ol><li><a href=#在-jsx-中只能在以下两种场景中使用大括号>在 JSX 中，只能在以下两种场景中使用大括号</a></li><li><a href=#使用-双大括号jsx-中的-css-和-对象>使用 “双大括号”：JSX 中的 CSS 和 对象</a></li></ol></li><li><a href=#props>props</a></li><li><a href=#条件渲染>条件渲染</a></li><li><a href=#key>key</a><ol><li><a href=#如何设定-key-值>如何设定 key 值</a></li><li><a href=#key-需要满足的条件>key 需要满足的条件</a></li><li><a href=#react-中为什么需要-key>React 中为什么需要 key？</a></li></ol></li><li><a href=#保持组件纯粹>保持组件纯粹</a></li><li><a href=#传递给事件的函数>传递给事件的函数</a></li><li><a href=#事件的传播>事件的传播</a></li><li><a href=#阻止传播>阻止传播</a></li><li><a href=#阻止默认行为>阻止默认行为</a></li><li><a href=#usestate>useState</a><ol><li><a href=#设置-state-不会更改现有渲染中的变量但会请求一次新的渲染>设置 state 不会更改现有渲染中的变量，但会请求一次新的渲染。</a></li><li><a href=#react-会在事件处理函数执行完成之后处理-state-更新这被称为批处理>React 会在事件处理函数执行完成之后处理 state 更新。这被称为批处理。</a></li><li><a href=#要在一个事件中多次更新某些-state你可以使用-setnumbern--n--1-更新函数>要在一个事件中多次更新某些 state，你可以使用 setNumber(n => n + 1) 更新函数。</a></li><li><a href=#将-state-视为只读的>将 state 视为只读的</a></li><li><a href=#局部-mutation-是可以接受的>局部 mutation 是可以接受的</a></li><li><a href=#使用展开语法复制对象>使用展开语法复制对象</a></li><li><a href=#更新一个嵌套对象>更新一个嵌套对象</a></li><li><a href=#使用-immer-编写简洁的更新逻辑>使用 Immer 编写简洁的更新逻辑</a></li><li><a href=#在没有-mutation-的前提下更新数组>在没有 mutation 的前提下更新数组</a></li></ol></li><li><a href=#useref>useRef</a><ol><li><a href=#给你的组件添加-ref>给你的组件添加 ref</a></li><li><a href=#ref-和-state-的不同之处>ref 和 state 的不同之处</a></li><li><a href=#使用-ref-操作-dom>使用 ref 操作 DOM</a></li></ol></li><li><a href=#useeffect>useEffect</a><ol><li><a href=#如何编写-effect>如何编写 Effect</a></li><li><a href=#注意事项>注意事项</a></li></ol></li><li><a href=#usememo性能优化的手段>useMemo(性能优化的手段)</a><ol><li><a href=#用法>用法</a></li></ol></li><li><a href=#usecallback>useCallback</a><ol><li><a href=#用法-1>用法</a></li></ol></li><li><a href=#usecallback-与-usememo-有何关系>useCallback 与 useMemo 有何关系？</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/react/ style=background-color:#2a9d8f;color:#fff>React</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E5%85%B3%E4%BA%8Ereact%E7%9A%84%E7%AC%94%E8%AE%B0/>关于React的笔记</a></h2><h3 class=article-subtitle>记录一些React笔记</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 22, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 17 分钟</time></div></footer></div></header><section class=article-content><h2 id=前言>前言</h2><p>本笔记不是零基础笔记</p><h2 id=react-组件名称>React 组件名称</h2><p>React 组件是常规的 JavaScript 函数，但 组件的名称必须以<strong>大写字母开头</strong>，否则它们将无法运行！</p><h2 id=jsx-的规则>jsx 的规则</h2><h3 id=jsx-的-return>jsx 的 return</h3><p>这个组件返回一个带有 src 和 alt 属性的 <img> 标签。<img> 写得像 HTML，但实际上是 JavaScript！这种语法被称为 JSX，它允许你在 JavaScript 中嵌入标签。</p><p>返回语句可以全写在一行上，如下面组件中所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=ln>1</span><span class=cl><span class=k>return</span> <span class=p>&lt;</span><span class=nt>img</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://i.imgur.com/MK3eW3As.jpg&#34;</span> <span class=na>alt</span><span class=o>=</span><span class=s>&#34;Katherine Johnson&#34;</span> <span class=p>/&gt;;</span>
</span></span></code></pre></div><p>但是，如果你的标签和 return 关键字不在同一行，则必须把它包裹在一对括号中，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=ln>1</span><span class=cl><span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>  <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=p>&lt;</span><span class=nt>img</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://i.imgur.com/MK3eW3As.jpg&#34;</span> <span class=na>alt</span><span class=o>=</span><span class=s>&#34;Katherine Johnson&#34;</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>  <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p><strong>没有括号包裹的话，任何在 return 下一行的代码都 将被忽略！</strong></p><p>JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你<strong>不能在一个函数中返回多个对象，除非用一个数组把他们包装起来</strong>。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。</p><h3 id=标签必须闭合>标签必须闭合</h3><p>JSX 要求标签必须正确闭合。像 <code>&lt;img></code> 这样的自闭合标签必须书写成 <code>&lt;img /></code>，而像 <code>&lt;li>oranges</code> 这样只有开始标签的元素必须带有闭合标签，需要改为 <code>&lt;li>oranges&lt;/li></code>。</p><h3 id=使用驼峰式命名法给-所有-大部分属性命名>使用驼峰式命名法给 所有 大部分属性命名！</h3><p>JSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。在你自己的组件中，经常会遇到需要用变量的方式读取这些属性的时候。但 JavaScript 对变量的命名有限制。例如，变量名称不能包含 - 符号或者像 class 这样的保留字。</p><p>这就是为什么在 React 中，大部分 HTML 和 SVG 属性都用驼峰式命名法表示。例如，需要用 strokeWidth 代替 stroke-width。由于 class 是一个保留字，所以在 React 中需要用 className 来代替。这也是 DOM 属性中的命名。</p><h2 id=默认导出与具名导出>默认导出与具名导出</h2><div class=table-wrapper><table><thead><tr><th>语法</th><th>导出语句</th><th>导入语句</th></tr></thead><tbody><tr><td>默认</td><td><code>export default function Button() {}</code></td><td><code>import Button from './Button.js';</code></td></tr><tr><td>具名</td><td><code>export function Button() {}</code></td><td><code>import { Button } from './Button.js';</code></td></tr></tbody></table></div><p>一个文件里有且仅有一个 默认 导出，但是可以有任意多个 具名 导出。</p><p>当使用默认导入时，你可以在 import 语句后面进行任意命名。比如 import Banana from &lsquo;./Button.js&rsquo;，如此你能获得与默认导出一致的内容。相反，对于具名导入，导入和导出的名字必须一致。这也是称其为 具名 导入的原因！</p><p>通常，文件中仅包含一个组件时，人们会选择默认导出，而当文件中包含多个组件或某个值需要导出时，则会选择具名导出。 无论选择哪种方式，请记得给你的组件和相应的文件命名一个有意义的名字。不建议创建未命名的组件，比如 export default () => {}，因为这样会使得调试变得异常困难。</p><h2 id=在大括号---中使用-javascript>在大括号 { } 中使用 JavaScript</h2><h3 id=在-jsx-中只能在以下两种场景中使用大括号>在 JSX 中，只能在以下两种场景中使用大括号</h3><p>用作 JSX 标签内的文本：<code>&lt;h1>{name}'s To Do List&lt;/h1></code>是有效的，但是 <code>&lt;{tag}>Gregorio Y. Zara's To Do List&lt;/{tag}></code> 无效。
用作紧跟在 = 符号后的 属性：<code>src={avatar}</code> 会读取 <code>avatar</code> 变量，但是 <code>src="{avatar}"</code> 只会传一个字符串 <code>{avatar}</code>。</p><h3 id=使用-双大括号jsx-中的-css-和-对象>使用 “双大括号”：JSX 中的 CSS 和 对象</h3><p>除了字符串、数字和其它 JavaScript 表达式，你甚至可以在 JSX 中传递对象。对象也用大括号表示，例如 <code>{ name: "Hedy Lamarr", inventions: 5 }</code>。因此，为了能在 JSX 中传递，你必须用另一对额外的大括号包裹对象：<code>person={{ name: "Hedy Lamarr", inventions: 5 }}</code>。</p><p>你可能在 JSX 的内联 CSS 样式中就已经见过这种写法了。React 不要求你使用内联样式（使用 CSS 类就能满足大部分情况）。但是当你需要内联样式的时候，你可以给 style 属性传递一个对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln> 1</span><span class=cl><span class=k>export</span> <span class=n>default</span> <span class=n>function</span> <span class=n>TodoList</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=o>&lt;</span><span class=n>ul</span> <span class=n>style</span><span class=o>=</span><span class=p>{{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>      <span class=n>backgroundColor</span><span class=p>:</span> <span class=s1>&#39;black&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>      <span class=n>color</span><span class=p>:</span> <span class=s1>&#39;pink&#39;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=p>}}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>      <span class=o>&lt;</span><span class=n>li</span><span class=o>&gt;</span><span class=n>Improve</span> <span class=n>the</span> <span class=n>videophone</span><span class=o>&lt;/</span><span class=n>li</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>      <span class=o>&lt;</span><span class=n>li</span><span class=o>&gt;</span><span class=n>Prepare</span> <span class=n>aeronautics</span> <span class=n>lectures</span><span class=o>&lt;/</span><span class=n>li</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>      <span class=o>&lt;</span><span class=n>li</span><span class=o>&gt;</span><span class=n>Work</span> <span class=n>on</span> <span class=n>the</span> <span class=n>alcohol</span><span class=o>-</span><span class=n>fuelled</span> <span class=n>engine</span><span class=o>&lt;/</span><span class=n>li</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=o>&lt;/</span><span class=n>ul</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意，内联 style 属性 使用驼峰命名法编写。例如，HTML <code>&lt;ul style="background-color: black"></code> 在你的组件里应该写成 <code>&lt;ul style={{ backgroundColor: 'black' }}></code>。</p><p>所以当你下次在 JSX 中看到 <code>{{ }}</code>时，就知道它只不过是包在大括号里的一个对象罢了！</p><h2 id=props>props</h2><ul><li>要传递 props，请将它们添加到 JSX，就像使用 HTML 属性一样。</li><li>要读取 props，请使用 <code>function Avatar({ person, size })</code> 解构语法。</li><li>你可以指定一个默认值，如 size = 100，用于缺少值或值为 undefined 的 props 。</li><li>你可以使用 <code>&lt;Avatar {...props} /> </code>JSX 展开语法转发所有 props，但不要过度使用它！</li><li>像 <code>&lt;Card>&lt;Avatar />&lt;/Card></code> 这样的嵌套 JSX，将被视为 Card 组件的 children prop。</li><li>Props 是只读的时间快照：每次渲染都会收到新版本的 props。</li><li>你不能改变 props。当你需要交互性时，你可以设置 state。</li></ul><h2 id=条件渲染>条件渲染</h2><ul><li>在 React，你可以使用 JavaScript 来控制分支逻辑。</li><li>你可以使用 if 语句来选择性地返回 JSX 表达式。</li><li>你可以选择性地将一些 JSX 赋值给变量，然后用大括号将其嵌入到其他 JSX 中。</li><li>在 JSX 中，<code>{cond ? &lt;A /> : &lt;B />}</code> 表示 “当 cond 为真值时, 渲染 <code>&lt;A /></code>，否则 <code>&lt;B /></code>”。</li><li>在 JSX 中，<code>{cond && &lt;A />}</code> 表示 “当 cond 为真值时, 渲染 <a>，否则不进行渲染”。</li><li>快捷的表达式很常见，但如果你更倾向于使用 if，你也可以不使用它们。</li></ul><h2 id=key>key</h2><h3 id=如何设定-key-值>如何设定 key 值</h3><p>不同来源的数据往往对应不同的 key 值获取方式：</p><p>来自数据库的数据： 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。
本地产生数据： 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 uuid 的库来生成 key。</p><h3 id=key-需要满足的条件>key 需要满足的条件</h3><p>key 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。</p><p>key 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。</p><h3 id=react-中为什么需要-key>React 中为什么需要 key？</h3><p>设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……</p><p>React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。</p><h2 id=保持组件纯粹>保持组件纯粹</h2><ul><li><p>一个组件必须是纯粹的，就意味着：</p><ul><li>只负责自己的任务。 它不会更改在该函数调用前就已存在的对象或变量。</li><li>输入相同，则输出相同。 给定相同的输入，组件应该总是返回相同的 JSX。</li></ul></li><li><p>渲染随时可能发生，因此组件不应依赖于彼此的渲染顺序。</p></li><li><p>你不应该改变任何用于组件渲染的输入。这包括 props、state 和 context。通过 “设置” state 来更新界面，而不要改变预先存在的对象。</p></li><li><p>努力在你返回的 JSX 中表达你的组件逻辑。当你需要“改变事物”时，你通常希望在事件处理程序中进行。作为最后的手段，你可以使用 useEffect。</p></li></ul><h2 id=传递给事件的函数>传递给事件的函数</h2><div class=table-wrapper><table><thead><tr><th>传递一个函数（正确）</th><th>调用一个函数（错误）</th></tr></thead><tbody><tr><td><code>&lt;button onClick={handleClick}></code></td><td><code>&lt;button onClick={handleClick()}></code></td></tr></tbody></table></div><p>区别很微妙。在第一个示例中，handleClick 函数作为 onClick 事件处理函数传递。这会让 React 记住它，并且只在用户点击按钮时调用你的函数。</p><p>在第二个示例中，handleClick() 中最后的 () 会在 渲染 过程中 立即 触发函数，即使没有任何点击。这是因为位于 JSX {} 之间的 JavaScript 会立即执行。</p><div class=table-wrapper><table><thead><tr><th>传递一个函数（正确）</th><th>调用一个函数（错误）</th></tr></thead><tbody><tr><td><code>&lt;button onClick={() => alert('...')}></code></td><td><code>&lt;button onClick={alert('...')}></code></td></tr></tbody></table></div><p>如果按如下方式传递内联代码，并不会在点击时触发，而是会在每次组件渲染时触发：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>// 这个 alert 在组件渲染时触发，而不是点击时触发！
</span></span><span class=line><span class=ln>2</span><span class=cl>&lt;button onClick={alert(&#39;你点击了我！&#39;)}&gt;
</span></span></code></pre></div><p>如果你想要定义内联事件处理函数，请将其包装在匿名函数中，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>&lt;button onClick={() =&gt; alert(&#39;你点击了我！&#39;)}&gt;
</span></span></code></pre></div><p>这里创建了一个稍后调用的函数，而不会在每次渲染时执行其内部代码。</p><p>在这两种情况下，你都应该传递一个函数：</p><ul><li><code>&lt;button onClick={handleClick}></code> 传递了 handleClick 函数。</li><li><code>&lt;button onClick={() => alert('...')}></code> 传递了 () => alert(&rsquo;&mldr;&rsquo;) 函数。</li></ul><h2 id=事件的传播>事件的传播</h2><p>在 React 中所有事件都会传播，除了 onScroll，它仅适用于你附加到的 JSX 标签。</p><h2 id=阻止传播>阻止传播</h2><p>事件处理函数接收一个 事件对象 作为唯一的参数。按照惯例，它通常被称为 e ，代表 “event”（事件）。你可以使用此对象来读取有关事件的信息。</p><p>这个事件对象还允许你阻止传播。如果你想阻止一个事件到达父组件，你需可以调用 e.stopPropagation() ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln> 1</span><span class=cl><span class=n>function</span> <span class=ne>Button</span><span class=p>({</span> <span class=n>onClick</span><span class=p>,</span> <span class=n>children</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=o>&lt;</span><span class=n>button</span> <span class=n>onClick</span><span class=o>=</span><span class=p>{</span><span class=n>e</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>      <span class=n>e</span><span class=o>.</span><span class=n>stopPropagation</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>      <span class=n>onClick</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=p>}}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>      <span class=p>{</span><span class=n>children</span><span class=p>}</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=o>&lt;/</span><span class=n>button</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=k>export</span> <span class=n>default</span> <span class=n>function</span> <span class=n>Toolbar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=o>&lt;</span><span class=n>div</span> <span class=n>className</span><span class=o>=</span><span class=s2>&#34;Toolbar&#34;</span> <span class=n>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>      <span class=n>alert</span><span class=p>(</span><span class=s1>&#39;你点击了 toolbar ！&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=p>}}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>      <span class=o>&lt;</span><span class=ne>Button</span> <span class=n>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=n>alert</span><span class=p>(</span><span class=s1>&#39;正在播放！&#39;</span><span class=p>)}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>        <span class=err>播放电影</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>      <span class=o>&lt;/</span><span class=ne>Button</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>      <span class=o>&lt;</span><span class=ne>Button</span> <span class=n>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=n>alert</span><span class=p>(</span><span class=s1>&#39;正在上传！&#39;</span><span class=p>)}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>        <span class=err>上传图片</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>      <span class=o>&lt;/</span><span class=ne>Button</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=o>&lt;/</span><span class=n>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=ln>25</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=阻止默认行为>阻止默认行为</h2><p>某些浏览器事件具有与事件相关联的默认行为。例如，点击<form>表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面</p><p>你可以调用事件对象中的 e.preventDefault() 来阻止这种情况发生</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln> 1</span><span class=cl><span class=k>export</span> <span class=n>default</span> <span class=n>function</span> <span class=n>Signup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=o>&lt;</span><span class=n>form</span> <span class=n>onSubmit</span><span class=o>=</span><span class=p>{</span><span class=n>e</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>      <span class=n>e</span><span class=o>.</span><span class=n>preventDefault</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>      <span class=n>alert</span><span class=p>(</span><span class=s1>&#39;提交表单！&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=p>}}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>      <span class=o>&lt;</span><span class=n>input</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>      <span class=o>&lt;</span><span class=n>button</span><span class=o>&gt;</span><span class=err>发送</span><span class=o>&lt;/</span><span class=n>button</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=o>&lt;/</span><span class=n>form</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=usestate>useState</h2><h3 id=设置-state-不会更改现有渲染中的变量但会请求一次新的渲染>设置 state 不会更改现有渲染中的变量，但会请求一次新的渲染。</h3><p>设置 state 的调用是在告诉 React：&ldquo;组件状态已更新，请安排一个新的渲染周期来反映这一变化。&rdquo;</p><ol><li><p>当你调用 setState 时，React 并不会立即修改当前渲染（即已经生成的虚拟 DOM）中的变量。这意味着，在当前的渲染过程中，你依然看到的是旧的状态值。</p></li><li><p>setState 调用其实是异步的。它会在内部标记组件需要更新，但真正的更新和重新渲染会在稍后的时机发生（通常是在事件处理结束或其他合适的时机）。更新后的状态会在下一次渲染时生效。</p></li><li><p>当新的渲染触发后，React 会创建一个全新的虚拟 DOM，并使用更新后的 state 生成新的 UI，然后再比较前后两次虚拟 DOM 的变化，并只更新浏览器中实际变动的部分（即“调和”过程）。</p></li></ol><p>总结来说，设置 state 不会修改当前渲染的变量，它只是请求一次新的渲染，在下一个渲染周期中使用新的 state 来重新计算和更新 UI。这种机制有助于保持组件状态的不可变性和渲染的一致性。</p><h3 id=react-会在事件处理函数执行完成之后处理-state-更新这被称为批处理>React 会在事件处理函数执行完成之后处理 state 更新。这被称为批处理。</h3><p>只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。这种特性也就是 批处理，它会使你的 React 应用运行得更快。它还会帮你避免处理只 ​​ 更新了一部分 state 变量的令人困惑的“半成品”渲染。</p><p>React 不会跨 多个 需要刻意触发的事件（如点击）进行批处理——每次点击都是单独处理的。请放心，React 只会在一般来说安全的情况下才进行批处理。这可以确保，例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。</p><h3 id=要在一个事件中多次更新某些-state你可以使用-setnumbern--n--1-更新函数>要在一个事件中多次更新某些 state，你可以使用 setNumber(n => n + 1) 更新函数。</h3><h3 id=将-state-视为只读的>将 state 视为只读的</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>onPointerMove={e =&gt; {
</span></span><span class=line><span class=ln>2</span><span class=cl>  position.x = e.clientX;
</span></span><span class=line><span class=ln>3</span><span class=cl>  position.y = e.clientY;
</span></span><span class=line><span class=ln>4</span><span class=cl>}}
</span></span></code></pre></div><p>这段代码直接修改了 上一次渲染中 分配给 position 的对象。但是因为并没有使用 state 的设置函数，React 并不知道对象已更改。所以 React 没有做出任何响应。虽然在一些情况下，直接修改 state 可能是有效的，但并不推荐这么做。你应该把在渲染过程中可以访问到的 state 视为只读的。</p><p>在这种情况下，为了真正地 触发一次重新渲染，你需要创建一个新对象并把它传递给 state 的设置函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>onPointerMove={e =&gt; {
</span></span><span class=line><span class=ln>2</span><span class=cl>  setPosition({
</span></span><span class=line><span class=ln>3</span><span class=cl>    x: e.clientX,
</span></span><span class=line><span class=ln>4</span><span class=cl>    y: e.clientY
</span></span><span class=line><span class=ln>5</span><span class=cl>  });
</span></span><span class=line><span class=ln>6</span><span class=cl>}}
</span></span></code></pre></div><p>通过使用 setPosition，你在告诉 React：</p><p>使用这个新的对象替换 position 的值,然后再次渲染这个组件</p><h3 id=局部-mutation-是可以接受的>局部 mutation 是可以接受的</h3><p>像这样的代码是有问题的，因为它改变了 state 中现有的对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>position.x = e.clientX;
</span></span><span class=line><span class=ln>2</span><span class=cl>position.y = e.clientY;
</span></span></code></pre></div><p>但是像这样的代码就 没有任何问题，因为你改变的是你刚刚创建的一个新的对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln>1</span><span class=cl><span class=k>const</span> <span class=n>nextPosition</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>nextPosition</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=n>clientX</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=n>nextPosition</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=n>clientY</span><span class=p>;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=n>setPosition</span><span class=p>(</span><span class=n>nextPosition</span><span class=p>);</span>
</span></span></code></pre></div><p>事实上，它完全等同于下面这种写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>setPosition({
</span></span><span class=line><span class=ln>2</span><span class=cl>  x: e.clientX,
</span></span><span class=line><span class=ln>3</span><span class=cl>  y: e.clientY
</span></span><span class=line><span class=ln>4</span><span class=cl>});
</span></span></code></pre></div><p>只有当你改变已经处于 state 中的 现有 对象时，mutation 才会成为问题。而修改一个你刚刚创建的对象就不会出现任何问题，因为 还没有其他的代码引用它。改变它并不会意外地影响到依赖它的东西。这叫做“局部 mutation”。你甚至可以 在渲染的过程中 进行“局部 mutation”的操作。这种操作既便捷又没有任何问题！</p><h3 id=使用展开语法复制对象>使用展开语法复制对象</h3><p>下面这行代码修改了上一次渲染中的 state：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>person.firstName = e.target.value;
</span></span></code></pre></div><p>想要实现你的需求，最可靠的办法就是创建一个新的对象并将它传递给 setPerson。但是在这里，你还需要 把当前的数据复制到新对象中，因为你只改变了其中一个字段：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>setPerson({
</span></span><span class=line><span class=ln>2</span><span class=cl>  firstName: e.target.value, // 从 input 中获取新的 first name
</span></span><span class=line><span class=ln>3</span><span class=cl>  lastName: person.lastName,
</span></span><span class=line><span class=ln>4</span><span class=cl>  email: person.email
</span></span><span class=line><span class=ln>5</span><span class=cl>});
</span></span></code></pre></div><p>你可以使用<code>...</code>对象展开 语法，这样你就不需要单独复制每个属性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>setPerson({
</span></span><span class=line><span class=ln>2</span><span class=cl>  ...person, // 复制上一个 person 中的所有字段
</span></span><span class=line><span class=ln>3</span><span class=cl>  firstName: e.target.value // 但是覆盖 firstName 字段
</span></span><span class=line><span class=ln>4</span><span class=cl>});
</span></span></code></pre></div><p>对于大型表单，将所有数据都存放在同一个对象中是非常方便的——前提是你能够正确地更新它！</p><p>请注意<code>...</code>展开语法本质是是“浅拷贝”——它只会复制一层。这使得它的执行速度很快，但是也意味着当你想要更新一个嵌套属性时，你必须得多次使用展开语法。</p><h3 id=更新一个嵌套对象>更新一个嵌套对象</h3><p>考虑下面这种结构的嵌套对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln>1</span><span class=cl><span class=k>const</span> <span class=p>[</span><span class=n>person</span><span class=p>,</span> <span class=n>setPerson</span><span class=p>]</span> <span class=o>=</span> <span class=n>useState</span><span class=p>({</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>  <span class=n>name</span><span class=p>:</span> <span class=s1>&#39;Niki de Saint Phalle&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>  <span class=n>artwork</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=n>title</span><span class=p>:</span> <span class=s1>&#39;Blue Nana&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>    <span class=n>city</span><span class=p>:</span> <span class=s1>&#39;Hamburg&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>    <span class=n>image</span><span class=p>:</span> <span class=s1>&#39;https://i.imgur.com/Sd1AgUOm.jpg&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>7</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>8</span><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>如果你想要更新 person.artwork.city 的值，用 mutation 来实现的方法非常容易理解：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>person.artwork.city = &#39;New Delhi&#39;;
</span></span></code></pre></div><p>但是在 React 中，你需要将 state 视为不可变的！为了修改 city 的值，你首先需要创建一个新的 artwork 对象（其中预先填充了上一个 artwork 对象中的数据），然后创建一个新的 person 对象，并使得其中的 artwork 属性指向新创建的 artwork 对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln>1</span><span class=cl><span class=k>const</span> <span class=n>nextArtwork</span> <span class=o>=</span> <span class=p>{</span> <span class=o>...</span><span class=n>person</span><span class=o>.</span><span class=n>artwork</span><span class=p>,</span> <span class=n>city</span><span class=p>:</span> <span class=s1>&#39;New Delhi&#39;</span> <span class=p>};</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=k>const</span> <span class=n>nextPerson</span> <span class=o>=</span> <span class=p>{</span> <span class=o>...</span><span class=n>person</span><span class=p>,</span> <span class=n>artwork</span><span class=p>:</span> <span class=n>nextArtwork</span> <span class=p>};</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=n>setPerson</span><span class=p>(</span><span class=n>nextPerson</span><span class=p>);</span>
</span></span></code></pre></div><p>或者，写成一个函数调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>setPerson({
</span></span><span class=line><span class=ln>2</span><span class=cl>  ...person, // 复制其它字段的数据
</span></span><span class=line><span class=ln>3</span><span class=cl>  artwork: { // 替换 artwork 字段
</span></span><span class=line><span class=ln>4</span><span class=cl>    ...person.artwork, // 复制之前 person.artwork 中的数据
</span></span><span class=line><span class=ln>5</span><span class=cl>    city: &#39;New Delhi&#39; // 但是将 city 的值替换为 New Delhi！
</span></span><span class=line><span class=ln>6</span><span class=cl>  }
</span></span><span class=line><span class=ln>7</span><span class=cl>});
</span></span></code></pre></div><h3 id=使用-immer-编写简洁的更新逻辑>使用 Immer 编写简洁的更新逻辑</h3><p>如果你的 state 有多层的嵌套，你或许应该考虑 将其扁平化。但是，如果你不想改变 state 的数据结构，你可能更喜欢用一种更便捷的方式来实现嵌套展开的效果。Immer 是一个非常流行的库，它可以让你使用简便但可以直接修改的语法编写代码，并会帮你处理好复制的过程。通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>updatePerson(draft =&gt; {
</span></span><span class=line><span class=ln>2</span><span class=cl>  draft.artwork.city = &#39;Lagos&#39;;
</span></span><span class=line><span class=ln>3</span><span class=cl>});
</span></span></code></pre></div><p>但是不同于一般的 mutation，它并不会覆盖之前的 state！</p><p>尝试使用 Immer:</p><ul><li>运行 <code>npm install use-immer</code> 添加 Immer 依赖</li><li>用 <code>import { useImmer } from 'use-immer'</code> 替换掉 <code>import { useState } from 'react'</code></li></ul><h3 id=在没有-mutation-的前提下更新数组>在没有 mutation 的前提下更新数组</h3><p>在 JavaScript 中，数组只是另一种对象。同对象一样，你需要将 React state 中的数组视为只读的。这意味着你不应该使用类似于 arr[0] = &lsquo;bird&rsquo; 这样的方式来重新分配数组中的元素，也不应该使用会直接修改原始数组的方法，例如 push() 和 pop()。</p><p>相反，每次要更新一个数组时，你需要把一个新的数组传入 state 的 setting 方法中。为此，你可以通过使用像 filter() 和 map() 这样不会直接修改原始值的方法，从原始数组生成一个新的数组。然后你就可以将 state 设置为这个新生成的数组。</p><p>下面是常见数组操作的参考表。当你操作 React state 中的数组时，你需要避免使用左列的方法，而首选右列的方法：</p><div class=table-wrapper><table><thead><tr><th>操作</th><th>避免使用 (会改变原始数组)</th><th>推荐使用 (会返回一个新数组）</th></tr></thead><tbody><tr><td>添加元素</td><td>push，unshift</td><td>concat，[&mldr;arr] 展开语法</td></tr><tr><td>删除元素</td><td>pop，shift，splice</td><td>filter，slice</td></tr><tr><td>替换元素</td><td>splice，arr[i] = &mldr; 赋值</td><td>map</td></tr><tr><td>排序</td><td>reverse，sort</td><td>先将数组复制一份</td></tr></tbody></table></div><h2 id=useref>useRef</h2><h3 id=给你的组件添加-ref>给你的组件添加 ref</h3><p>你可以通过从 React 导入 useRef Hook 来为你的组件添加一个 ref：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>import { useRef } from &#39;react&#39;;
</span></span></code></pre></div><p>在你的组件内，调用 useRef Hook 并传入你想要引用的初始值作为唯一参数。例如，这里的 ref 引用的值是“0”：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln>1</span><span class=cl><span class=k>const</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>useRef</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><p>useRef 返回一个这样的对象:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>{
</span></span><span class=line><span class=ln>2</span><span class=cl>  current: 0 // 你向 useRef 传入的值
</span></span><span class=line><span class=ln>3</span><span class=cl>}
</span></span></code></pre></div><p>与 state 不同的是，ref 是一个普通的 JavaScript 对象，具有可以被读取和修改的 current 属性。</p><p>你可以用 ref.current 属性访问该 ref 的当前值。这个值是有意被设置为可变的，意味着你既可以读取它也可以写入它。就像一个 React 追踪不到的、用来存储组件信息的秘密“口袋”。（这就是让它成为 React 单向数据流的“脱围机制”的原因）</p><h3 id=ref-和-state-的不同之处>ref 和 state 的不同之处</h3><div class=table-wrapper><table><thead><tr><th></th><th>useRef</th><th>useState</th></tr></thead><tbody><tr><td>返回值</td><td>useRef(initialValue) 返回 <code>{ current: initialValue }</code></td><td>useState(initialValue) 返回 <code>[value, setValue]</code></td></tr><tr><td>触发渲染</td><td>更改时不会触发重新渲染</td><td>更改时触发重新渲染</td></tr><tr><td>可变性</td><td>可变 —— 你可以在渲染过程之外修改和更新 <code>current</code> 的值。</td><td>“不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。</td></tr><tr><td>读取/写入时机</td><td>你不应在渲染期间读取（或写入） <code>current</code> 值。</td><td>你可以随时读取 state。但是，每次渲染都有自己不变的 state 快照。</td></tr></tbody></table></div><h3 id=使用-ref-操作-dom>使用 ref 操作 DOM</h3><p>要访问由 React 管理的 DOM 节点，首先，引入 useRef Hook：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>import { useRef } from &#39;react&#39;;
</span></span></code></pre></div><p>然后，在你的组件中使用它声明一个 ref：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln>1</span><span class=cl><span class=k>const</span> <span class=n>myRef</span> <span class=o>=</span> <span class=n>useRef</span><span class=p>(</span><span class=n>null</span><span class=p>);</span>
</span></span></code></pre></div><p>最后，将 ref 作为 ref 属性值传递给想要获取的 DOM 节点的 JSX 标签：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>&lt;div ref={myRef}&gt;
</span></span></code></pre></div><p>useRef Hook 返回一个对象，该对象有一个名为 current 的属性。最初，myRef.current 是 null。当 React 为这个<div>创建一个 DOM 节点时，React 会把对该节点的引用放入 myRef.current。然后，你可以从 事件处理器 访问此 DOM 节点，并使用在其上定义的内置浏览器 API。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>// 你可以使用任意浏览器 API，例如：
</span></span><span class=line><span class=ln>2</span><span class=cl>myRef.current.scrollIntoView();
</span></span></code></pre></div><h2 id=useeffect>useEffect</h2><h3 id=如何编写-effect>如何编写 Effect</h3><p>要编写一个 Effect, 请遵循以下三个步骤：</p><ol><li><strong><em>声明 Effect</em></strong>。通常 Effect 会在每次 提交 后运行。</li><li><strong>指定 Effect 依赖</strong>。大多数 Effect 应该按需运行，而不是在每次渲染后都运行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。你将通过指定 依赖项 来学习如何控制这一点。</li><li><strong>必要时添加清理操作</strong>。一些 Effect 需要指定如何停止、撤销，或者清除它们所执行的操作。例如，“连接”需要“断开”，“订阅”需要“退订”，而“获取数据”需要“取消”或者“忽略”。你将学习如何通过返回一个 清理函数 来实现这些。</li></ol><h3 id=注意事项>注意事项</h3><ul><li><p>每当你的组件渲染时，React 会先更新页面，然后再运行 useEffect 中的代码。换句话说，useEffect <strong>会“延迟”一段代码的运行，直到渲染结果反映在页面上</strong>。</p></li><li><p>默认情况下，Effect 会在 每次 渲染后运行。正因如此，以下代码会陷入死循环：</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln>1</span><span class=cl><span class=k>const</span> <span class=p>[</span><span class=n>count</span><span class=p>,</span> <span class=n>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=n>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>useEffect</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>  <span class=n>setCount</span><span class=p>(</span><span class=n>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=p>});</span>
</span></span></code></pre></div><ul><li>没有依赖数组和使用空数组 [] 作为依赖数组，行为是不同的：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln> 1</span><span class=cl>useEffect(() =&gt; {
</span></span><span class=line><span class=ln> 2</span><span class=cl>  // 这里的代码会在每次渲染后运行
</span></span><span class=line><span class=ln> 3</span><span class=cl>});
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl>useEffect(() =&gt; {
</span></span><span class=line><span class=ln> 6</span><span class=cl>  // 这里的代码只会在组件挂载（首次出现）时运行
</span></span><span class=line><span class=ln> 7</span><span class=cl>}, []);
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl>useEffect(() =&gt; {
</span></span><span class=line><span class=ln>10</span><span class=cl>  // 这里的代码不但会在组件挂载时运行，而且当 a 或 b 的值自上次渲染后发生变化后也会运行
</span></span><span class=line><span class=ln>11</span><span class=cl>}, [a, b]);
</span></span></code></pre></div><ul><li><p>为什么依赖数组中可以省略 ref?</p><p>这是因为 ref 具有 稳定 的标识：React 确保你在 每轮渲染中调用同一个 useRef 时，总能获得相同的对象。ref 不会改变，所以它不会导致重新运行 Effect。因此，在依赖数组中它可有可无。</p><p>useState 返回的 set 函数 也具有稳定的标识，因此它们通常也会被省略。如果在省略某个依赖项时 linter 不会报错，那么这么做就是安全的。</p><p>省略始终稳定的依赖项仅在 linter 能“看到”对象是稳定的时候才有效。例如，如果 ref 是从父组件传递过来的，则必须在依赖数组中指定它。这很有必要，因为你无法确定父组件是一直传递相同的 ref，还是根据条件传递不同的 ref。所以，你的 Effect 会依赖于被传递的是哪个 ref。</p></li><li><p>React 会在每次 Effect 重新运行之前调用清理函数，并在组件卸载（被移除）时最后一次调用清理函数。</p></li></ul><h2 id=usememo性能优化的手段>useMemo(性能优化的手段)</h2><h3 id=用法>用法</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln>1</span><span class=cl><span class=n>import</span> <span class=p>{</span> <span class=n>useMemo</span> <span class=p>}</span> <span class=n>from</span> <span class=s1>&#39;react&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=n>function</span> <span class=n>TodoList</span><span class=p>({</span> <span class=n>todos</span><span class=p>,</span> <span class=n>tab</span><span class=p>,</span> <span class=n>theme</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>  <span class=k>const</span> <span class=n>visibleTodos</span> <span class=o>=</span> <span class=n>useMemo</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=n>filterTodos</span><span class=p>(</span><span class=n>todos</span><span class=p>,</span> <span class=n>tab</span><span class=p>),</span> <span class=p>[</span><span class=n>todos</span><span class=p>,</span> <span class=n>tab</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>  <span class=o>//</span> <span class=o>...</span>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>你需要给 useMemo 传递两样东西：</p><ul><li>一个没有任何参数的 calculation 函数，像这样 () =>，并且返回任何你想要的计算结果。</li><li>一个由包含在你的组件中并在 calculation 中使用的所有值组成的 依赖列表。</li></ul><p>在初次渲染时，你从 useMemo 得到的 值 将会是你的 calculation 函数执行的结果。</p><p>在随后的每一次渲染中，React 将会比较前后两次渲染中的 所有依赖项 是否相同。如果通过 Object.is 比较所有依赖项都没有发生变化，那么 useMemo 将会返回之前已经计算过的那个值。否则，React 将会重新执行 calculation 函数并且返回一个新的值。</p><p>换言之，useMemo 在多次重新渲染中缓存了 calculation 函数计算的结果直到依赖项的值发生变化。</p><h2 id=usecallback>useCallback</h2><h3 id=用法-1>用法</h3><p>当你优化渲染性能的时候，有时需要缓存传递给子组件的函数。让我们先关注一下如何实现，稍后去理解在哪些场景中它是有用的。</p><p>为了缓存组件中多次渲染的函数，你需要将其定义在 useCallback Hook 中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln> 1</span><span class=cl><span class=n>import</span> <span class=p>{</span> <span class=n>useCallback</span> <span class=p>}</span> <span class=n>from</span> <span class=s1>&#39;react&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=n>function</span> <span class=n>ProductPage</span><span class=p>({</span> <span class=n>productId</span><span class=p>,</span> <span class=n>referrer</span><span class=p>,</span> <span class=n>theme</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>  <span class=k>const</span> <span class=n>handleSubmit</span> <span class=o>=</span> <span class=n>useCallback</span><span class=p>((</span><span class=n>orderDetails</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=n>post</span><span class=p>(</span><span class=s1>&#39;/product/&#39;</span> <span class=o>+</span> <span class=n>productId</span> <span class=o>+</span> <span class=s1>&#39;/buy&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>      <span class=n>referrer</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>      <span class=n>orderDetails</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=p>},</span> <span class=p>[</span><span class=n>productId</span><span class=p>,</span> <span class=n>referrer</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>  <span class=o>//</span> <span class=o>...</span>
</span></span></code></pre></div><p>你需要传递两个参数给 useCallback：</p><p>在多次渲染中需要缓存的函数</p><ul><li>函数内部需要使用到的所有组件内部值的 依赖列表。</li><li>初次渲染时，在 useCallback 处接收的 返回函数 将会是已经传入的函数。</li></ul><p>在之后的渲染中，React 将会使用 Object.is 把 当前的依赖 和已传入之前的依赖进行比较。如果没有任何依赖改变，useCallback 将会返回与之前一样的函数。否则 useCallback 将返回 此次 渲染中传递的函数。</p><p>简而言之，useCallback 在多次渲染中缓存一个函数，直至这个函数的依赖发生改变。</p><h2 id=usecallback-与-usememo-有何关系>useCallback 与 useMemo 有何关系？</h2><p>useMemo 经常与 useCallback 一同出现。当尝试优化子组件时，它们都很有用。他们会 记住（或者说，缓存）正在传递的东西：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln> 1</span><span class=cl><span class=n>import</span> <span class=p>{</span> <span class=n>useMemo</span><span class=p>,</span> <span class=n>useCallback</span> <span class=p>}</span> <span class=n>from</span> <span class=s1>&#39;react&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=n>function</span> <span class=n>ProductPage</span><span class=p>({</span> <span class=n>productId</span><span class=p>,</span> <span class=n>referrer</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>  <span class=k>const</span> <span class=n>product</span> <span class=o>=</span> <span class=n>useData</span><span class=p>(</span><span class=s1>&#39;/product/&#39;</span> <span class=o>+</span> <span class=n>productId</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=k>const</span> <span class=n>requirements</span> <span class=o>=</span> <span class=n>useMemo</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span> <span class=o>//</span><span class=err>调用函数并缓存结果</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=k>return</span> <span class=n>computeRequirements</span><span class=p>(</span><span class=n>product</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=p>},</span> <span class=p>[</span><span class=n>product</span><span class=p>]);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>
</span></span><span class=line><span class=ln>10</span><span class=cl>  <span class=k>const</span> <span class=n>handleSubmit</span> <span class=o>=</span> <span class=n>useCallback</span><span class=p>((</span><span class=n>orderDetails</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span> <span class=o>//</span> <span class=err>缓存函数本身</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=n>post</span><span class=p>(</span><span class=s1>&#39;/product/&#39;</span> <span class=o>+</span> <span class=n>productId</span> <span class=o>+</span> <span class=s1>&#39;/buy&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>      <span class=n>referrer</span><span class=p>,</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>      <span class=n>orderDetails</span><span class=p>,</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>  <span class=p>},</span> <span class=p>[</span><span class=n>productId</span><span class=p>,</span> <span class=n>referrer</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>
</span></span><span class=line><span class=ln>17</span><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=o>&lt;</span><span class=n>div</span> <span class=n>className</span><span class=o>=</span><span class=p>{</span><span class=n>theme</span><span class=p>}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>      <span class=o>&lt;</span><span class=n>ShippingForm</span> <span class=n>requirements</span><span class=o>=</span><span class=p>{</span><span class=n>requirements</span><span class=p>}</span> <span class=n>onSubmit</span><span class=o>=</span><span class=p>{</span><span class=n>handleSubmit</span><span class=p>}</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=o>&lt;/</span><span class=n>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=ln>22</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>区别在于你需要缓存 什么:</p><ul><li>useMemo 缓存函数调用的结果。在这里，它缓存了调用 computeRequirements(product) 的结果。除非 product 发生改变，否则它将不会发生变化。这让你向下传递 requirements 时而无需不必要地重新渲染 ShippingForm。必要时，React 将会调用传入的函数重新计算结果。</li><li>useCallback 缓存函数本身。不像 useMemo，它不会调用你传入的函数。相反，它缓存此函数。从而除非 productId 或 referrer 发生改变，handleSubmit 自己将不会发生改变。这让你向下传递 handleSubmit 函数而无需不必要地重新渲染 ShippingForm。直至用户提交表单，你的代码都将不会运行。</li></ul><p>如果你已经熟悉了 useMemo，你可能发现将 useCallback 视为以下内容会很有帮助：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>// 在 React 内部的简化实现
</span></span><span class=line><span class=ln>2</span><span class=cl>function useCallback(fn, dependencies) {
</span></span><span class=line><span class=ln>3</span><span class=cl>  return useMemo(() =&gt; fn, dependencies);
</span></span><span class=line><span class=ln>4</span><span class=cl>}
</span></span></code></pre></div></section><footer class=article-footer><section class=article-tags><a href=/tags/react/>React</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><script src=https://giscus.app/client.js data-repo=ltlylfun/ltlylfun.github.io data-repo-id=R_kgDON2LRBA data-category=Announcements data-category-id=DIC_kwDON2LRBM4CmxiY data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"noborder_gray")}})()</script><footer class=site-footer><section class=copyright>&copy; 2020 - 2025 ltlylfunBlog</section><section class=running-time>本博客已稳定运行
<span id=runningdays class=running-days></span></section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script type=text/javascript src=/ts/main.9eeb07c2996c35aae0e3e395e84530721297b213ef2a895edacbc42c59b09844.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>let s1="2025-2-08";s1=new Date(s1.replace(/-/g,"/"));let s2=new Date,timeDifference=s2.getTime()-s1.getTime(),days=Math.floor(timeDifference/(1e3*60*60*24)),hours=Math.floor(timeDifference%(1e3*60*60*24)/(1e3*60*60)),minutes=Math.floor(timeDifference%(1e3*60*60)/(1e3*60)),result=days+"天"+hours+"小时"+minutes+"分钟";document.getElementById("runningdays").innerHTML=result</script></body></html>