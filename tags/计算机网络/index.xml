<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机网络 on ltlylfunBlog</title><link>https://blog.ltlyl.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><description>Recent content in 计算机网络 on ltlylfunBlog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 20 Feb 2025 16:16:09 +0800</lastBuildDate><atom:link href="https://blog.ltlyl.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>关于TCP/UDP的笔记</title><link>https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/</link><pubDate>Thu, 20 Feb 2025 16:16:09 +0800</pubDate><guid>https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/</guid><description>&lt;h2 id="前言">前言
&lt;/h2>&lt;p>关于 TCP/UDP 的笔记。&lt;/p>
&lt;p>希望这些笔记不仅能帮助自己系统梳理知识，也能为其他学习计算机网络的朋友提供借鉴。&lt;/p>
&lt;p>PS 不定时更新，欢迎讨论区留言。&lt;/p>
&lt;h2 id="什么是-tcp">什么是 TCP？
&lt;/h2>&lt;p>TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>面向连接&lt;/strong>&lt;br>
在发送数据之前，通信双方会先通过一个称为“三次握手”（3-way handshake）的过程建立一条可靠的传输连接。只有连接建立完成后，数据传输才能开始。是一对一的，不能像 UDP 一样一对多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可靠传输&lt;/strong>&lt;br>
TCP 使用数据确认（ACK）、超时重传、重复确认（Duplicate ACK）等机制，确保数据包能够按顺序、完整地到达接收端。如果发生数据丢失或出错，TCP 能够自动进行重传，保证传输的可靠性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>面向字节流&lt;/strong>&lt;br>
TCP 将数据视为连续的字节流，而不是独立的数据包。这意味着在应用层数据的边界需要进行额外管理，例如通过消息分隔符或固定长度来标识每个独立的消息。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="tcp-与-udp-对比表">TCP 与 UDP 对比表
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>方面&lt;/strong>&lt;/th>
&lt;th>&lt;strong>TCP&lt;/strong>&lt;/th>
&lt;th>&lt;strong>UDP&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>面向连接&lt;/td>
&lt;td>是，需要建立连接（三次握手）后才能进行数据传输&lt;/td>
&lt;td>否，无连接，数据直接发送&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据可靠性&lt;/td>
&lt;td>高，具备数据确认、重传机制、累积确认和错误校验等措施，确保数据准确无误到达&lt;/td>
&lt;td>低，无内建确认和重传机制，数据可能丢失或乱序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据顺序&lt;/td>
&lt;td>保证按发送顺序到达&lt;/td>
&lt;td>不保证顺序，数据包独立传输&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>流量控制&lt;/td>
&lt;td>采用滑动窗口机制，根据接收方缓冲区大小动态控制数据发送速率&lt;/td>
&lt;td>无，发送数据完全由应用层控制，可能导致接收端被淹没&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>拥塞控制&lt;/td>
&lt;td>有，使用慢启动、拥塞避免、快速重传与快速恢复等算法，动态调整发送速率以应对网络拥塞&lt;/td>
&lt;td>无，不具备拥塞控制，可能在网络繁忙时频繁丢包&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>错误检测与恢复&lt;/td>
&lt;td>有，通过校验和及确认机制检测错误，并通过重传恢复丢失的数据&lt;/td>
&lt;td>仅有基本的校验和，不能进行错误恢复&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>头部开销&lt;/td>
&lt;td>较大，TCP 头部通常为 20 字节或以上，包含丰富的控制信息&lt;/td>
&lt;td>较小，仅 8 字节，结构简单&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>连接管理&lt;/td>
&lt;td>复杂，需经过三次握手建立连接及四次挥手断开连接，带来额外延时和资源开销&lt;/td>
&lt;td>简单，无需连接建立和断开，适用于快速传输&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>实时性&lt;/td>
&lt;td>相对较低，其可靠性保障和拥塞控制可能导致延迟上升，通常不适用于对延迟极度敏感的场景&lt;/td>
&lt;td>高，延迟低，适合实时视频、在线游戏、VoIP 等对时效性要求较高的应用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>适用场景&lt;/td>
&lt;td>文件传输、网页浏览、电子邮件、数据库通信等需要高可靠性和数据顺序保证的应用&lt;/td>
&lt;td>实时通讯、视频会议、在线游戏、DNS 查询、流媒体传输等可以容忍部分数据丢失，但要求低延迟的场景&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="tcp-和-udp-可以使同个端吗">TCP 和 UDP 可以使⽤同⼀个端⼝吗？
&lt;/h2>&lt;p>可以的。&lt;/p>
&lt;p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。&lt;/p>
&lt;p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。&lt;/p>
&lt;p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。&lt;/p>
&lt;p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。&lt;/p>
&lt;h2 id="序列号seq和初始序列号isn">序列号(SEQ)和初始序列号(ISN)
&lt;/h2>&lt;p>序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP
是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋
予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32
位的无符号数，因此在到达 4G 之后再循环回到 0。&lt;/p>
&lt;p>初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时
钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位
的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。&lt;/p>
&lt;h2 id="tcp-三次握手过程">TCP 三次握手过程
&lt;/h2>&lt;p>TCP 三次握手（Three-Way Handshake）是建立一个可靠的 TCP 连接的过程，通过交换控制信息来初始化连接参数。下面是详细的步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>第一次握手（SYN）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端向服务器发送一个带有 SYN 标志的报文段，该报文段包含客户端选择的初始序列号（ISN）。&lt;/li>
&lt;li>该报文段表示客户端希望与服务器建立连接。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: SYN, Seq = x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二次握手（SYN-ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>服务器收到客户端的 SYN 后，发送一个包含 SYN 和 ACK 标志的报文段给客户端。&lt;/li>
&lt;li>该报文段中，ACK 用来确认收到客户端的 SYN（Ack = x + 1），同时服务器也选择一个初始序列号（ISN = y）来建立自己的连接参数。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">服务器 → 客户端: SYN, ACK, Seq = y, Ack = x + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三次握手（ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端在收到服务器的 SYN-ACK 后，再发送一个只带 ACK 标志的报文段，作为对服务器响应的确认。&lt;/li>
&lt;li>该报文段中的 ACK 用来确认收到服务器的 SYN（Ack = y + 1）。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: ACK, Seq = x + 1, Ack = y + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>当服务器收到这个 ACK 后，双方就建立了一个可靠的 TCP 连接，可以进行后续数据传输了。&lt;/p>
&lt;h2 id="为什么需要三次握手而不是两次或四次">为什么需要三次握手，而不是两次或四次？
&lt;/h2>&lt;p>「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双方资源的浪费，也⽆法可靠的同步双⽅序列号。&lt;/p>
&lt;p>「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。&lt;/p>
&lt;h2 id="tcp-握手丢失情况">TCP 握手丢失情况
&lt;/h2>&lt;h3 id="tcp-第一次握手丢失的情况">TCP 第一次握手丢失的情况
&lt;/h3>&lt;p>当第一次握手丢失时，TCP 将通过重传策略来尝试恢复连接，但如果问题持续存在，连接将建立失败并反馈错误信息给应用程序。&lt;/p>
&lt;h3 id="tcp-第二次握手丢失的情况">TCP 第二次握手丢失的情况
&lt;/h3>&lt;p>当第二次握手丢失了，客户端和服务端都会重传。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由内核参数决定。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由内核参数决定。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tcp-第三次握手丢失的情况">TCP 第三次握手丢失的情况
&lt;/h3>&lt;p>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。直到收到第三次握⼿，或者达到最⼤重传次数。&lt;/p>
&lt;h2 id="tcp-四次挥手过程">TCP 四次挥手过程
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>第一次挥手（FIN）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端在没有数据发送后，向服务器发送一个带有 FIN 标志的报文段，以指示客户端不再有数据要发送。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: FIN, Seq = u
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二次挥手（ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>服务器收到客户端的 FIN 报文段后，立即发送一个 ACK 报文段作为确认，表明已接收到客户端停止发送数据的请求。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">服务器 → 客户端: ACK, Seq = v, Ack = u + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>此时，服务器可能仍有未传输完的数据，故数据传输方向上尚未完全关闭。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三次挥手（FIN）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当服务器完成剩余数据的传输后，会向客户端发送一个带有 FIN 标志的报文段，通知客户端服务器也没有数据要发送了，准备关闭连接。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">服务器 → 客户端: FIN, Seq = w
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第四次挥手（ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段以确认收到服务器关闭连接的请求。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: ACK, Seq = u + 1, Ack = w + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="为什么-tcp-挥手需要四次">为什么 TCP 挥手需要四次？
&lt;/h2>&lt;p>TCP 使用四次挥手断开连接，主要原因在于 TCP 连接是全双工的，也就是数据传输在两个方向上是独立的。在断开连接时，每个方向的数据传输都需要单独关闭。下面详细解释这一过程以及四次挥手的必要性：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>单向关闭&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当一方准备结束数据发送时，它只关闭自己的发送通道，但仍可接收数据。&lt;/li>
&lt;li>例如，当客户端发送一个 FIN 时，它表示自己没有数据要发送了，但仍然可以接收服务器的数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立的确认&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对于第一次 FIN（例如客户端发送的 FIN），服务器需要发送一个 ACK 来确认已经收到关闭请求。这只是对单个方向（客户端到服务器）的关闭确认。&lt;/li>
&lt;li>接下来，服务器完成自身数据发送后，也需要发送 FIN 来关闭其发送通道，客户端再对其进行确认。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>为何需要四次&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>第一步（客户端 FIN）：客户端通知服务器“我已经没有数据要发送了”。&lt;/li>
&lt;li>第二步（服务器 ACK）：服务器确认客户端的 FIN，并告知已接收，但此时仍可继续发送数据给客户端。&lt;/li>
&lt;li>第三步（服务器 FIN）：当服务器也结束发送数据后，它通知客户端“我也没有数据要发送了”。&lt;/li>
&lt;li>第四步（客户端 ACK）：客户端确认服务器的关闭请求，整个连接才能完全关闭。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可靠的连接终止&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>四次挥手确保了双方在断开连接前都能完成数据传输与确认，避免数据丢失。&lt;/li>
&lt;li>这种设计使得双方可以独立地结束各自的数据传输，从而达到安全、可靠地断开连接的目的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="什么情况会出现三次挥手">什么情况会出现三次挥手？
&lt;/h2>&lt;p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK(默认情
况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制)」，那么第二和第三
次挥手就会合并传输，这样就出现了三次挥手。&lt;/p>
&lt;h2 id="tcp-挥手丢失情况">TCP 挥手丢失情况
&lt;/h2>&lt;h3 id="tcp-第一次挥手丢失的情况">TCP 第一次挥手丢失的情况
&lt;/h3>&lt;p>当 TCP 第一次挥手的 FIN 报文丢失时，连接不会被立即关闭。主动关闭方会依赖重传机制来确保 FIN 最终传达到对方，一旦双方完成重传和确认，连接才会进入正常的终止流程。&lt;/p>
&lt;h3 id="tcp-第二次挥手丢失的情况">TCP 第二次挥手丢失的情况
&lt;/h3>&lt;p>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。&lt;/p>
&lt;h3 id="tcp-第三次挥手丢失的情况">TCP 第三次挥手丢失的情况
&lt;/h3>&lt;p>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。&lt;/p>
&lt;p>客户端因为是通过 close 函数关闭连接的，处于 FIN WAIT 2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手(FIN 报文)，那么客户端就会断开连接。&lt;/p>
&lt;h3 id="tcp-第四次挥手丢失的情况">TCP 第四次挥手丢失的情况
&lt;/h3>&lt;p>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2，达到了最大重传次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。&lt;/p>
&lt;p>客户端在收到第三次挥手后，就会进入 TIME WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手(FIN 报文)后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。&lt;/p>
&lt;h2 id="为什么需要-time_wait-状态">为什么需要 TIME_WAIT 状态？
&lt;/h2>&lt;p>防止历史连接中的数据，被后面相同四元组的连接错误的接收。&lt;/p>
&lt;p>保证「被动关闭连接」的一方，能被正确的关闭。&lt;/p>
&lt;h2 id="为什么每次建立-tcp-连接时初始化的序列号都要求不一样">为什么每次建立 TCP 连接时，初始化的序列号都要求不一样？
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>防止旧数据干扰&lt;/strong>&lt;br>
如果使用固定或者可预测的序列号，网络中可能还残留有上一次连接的数据包，在新连接建立后，这些旧数据包可能会被误认为是当前连接的数据，从而导致数据混乱或连接异常。选择唯一的 ISN 可以避免这种数据干扰问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>确保数据流正确排序&lt;/strong>&lt;br>
TCP 是一个面向字节流的协议，双方通过序列号来组织和排序数据。当每次连接的序列号都不相同时，可以确保即使出现重传或者网络延迟，接收方也能正确地将数据包按正确的顺序进行排序和重组。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>增强安全性&lt;/strong>&lt;br>
可预测的序列号可能给攻击者提供利用的机会，例如 TCP 序列号预测攻击。因此，每次连接都使用一个不容易预测的初始序列号，可以有效提升连接的安全性，降低恶意攻击的风险。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>区分不同连接&lt;/strong>&lt;br>
在同一对主机之间可能会在短时间内建立多个 TCP 连接。通过为每个连接选择不同的 ISN，可以帮助系统区分并管理这些连接，防止连接状态混淆。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="什么是-mtu">什么是 MTU
&lt;/h2>&lt;p>最大传输单元（英语：Maximum Transmission Unit，缩写 MTU）是指数据链路层上面所能通过的最大数据包大小（以字节为单位）。&lt;/p>
&lt;h2 id="什么是-mss">什么是 MSS？
&lt;/h2>&lt;p>最大分段大小（Maximum Segment Size）是传输控制协议的一个参数，以字节数定义一个计算机或通信设备所能接受的分段的最大数据量。 它并不会计算 TCP 或 IP 协议头的大小。即最大传输单元除去信头后的最大数据量。&lt;/p>
&lt;h2 id="为什么-tcp-层需要-mss">为什么 TCP 层需要 MSS？
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>降低 IP 分片的开销和风险&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分片开销&lt;/strong>：IP 分片不仅增加了每个数据包在网络上传输时的负担，还会影响路由器和接收主机的处理效率。每个分片都需要单独处理，如果分片过多，会导致额外的延时和资源消耗。&lt;/li>
&lt;li>&lt;strong>分片丢失问题&lt;/strong>：如果 IP 分片中的任一碎片丢失，整个数据包都必须重新传输。而且某些网络设备可能不支持 IP 分片或安全策略会丢弃分片，导致传输失败。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>提高传输效率与可靠性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>匹配底层网络 MTU&lt;/strong>：TCP 在连接建立时协商并计算对端的 MSS，通常依据路径 MTU（Path MTU）来计算。这样可以确保 TCP 报文段在封装进 IP 数据报之后，不会超出最低链路的 MTU，从而避免触发 IP 分片。&lt;/li>
&lt;li>&lt;strong>优化数据传输&lt;/strong>：合理的 MSS 可以使得每个 TCP 报文段刚好适应底层网络的 MTU，最大限度地利用网络带宽，确保传输的连续性和高效性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>简化错误处理&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用 MSS 限制 TCP 报文段大小可以降低由于 IP 分片引起的重传和错误处理的复杂度。如果发生数据丢失，整个 TCP 报文段丢失时，只需要重传一个比较小的单元，而不是一个由多个分片组成的大数据包。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>协商与兼容性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在 TCP 三次握手过程中，双方会交换 MSS 值，明确双方所能接受的最大报文段大小。这种协商有助于两端在一个共同的限制下进行通信，从而确保数据传输更加稳定和兼容不同网络环境。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="tcp-的粘包拆包以及解决方案">TCP 的粘包、拆包以及解决方案
&lt;/h2>&lt;p>&lt;img src="https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.jpeg"
width="1568"
height="1182"
srcset="https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85_hu_59cd60b8110afc0d.jpeg 480w, https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85_hu_2c3837d336d7b176.jpeg 1024w"
loading="lazy"
alt="粘包拆包"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="318px"
>&lt;/p>
&lt;p>上图中演示了以下几种情况：&lt;/p>
&lt;ul>
&lt;li>正常的理想情况，两个包恰好满足 TCP 缓冲区的大小或达到 TCP 等待时长，分别发送两个包；&lt;/li>
&lt;li>粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；&lt;/li>
&lt;li>拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；&lt;/li>
&lt;li>拆包和粘包：Packet1 过大，进行了拆包处理，而拆出去的一部分又与 Packet2 进行粘包处理。&lt;/li>
&lt;/ul>
&lt;h3 id="什么是粘包">什么是粘包？
&lt;/h3>&lt;p>指 TCP 协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。&lt;/p>
&lt;p>TCP 是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。&lt;/p>
&lt;h3 id="为什么-udp-没有粘包">为什么 UDP 没有粘包？
&lt;/h3>&lt;p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于 UDP 有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在 TCP 协议中。&lt;/p>
&lt;h3 id="粘包拆包发生场景">粘包拆包发生场景
&lt;/h3>&lt;p>因为 TCP 是面向流，没有边界，而操作系统在发送 TCP 数据时，会通过缓冲区来进行优化，例如缓冲区为 1024 个字节大小。&lt;/p>
&lt;p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。&lt;/p>
&lt;p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包。&lt;/p>
&lt;h3 id="常见的解决方案">常见的解决方案
&lt;/h3>&lt;ul>
&lt;li>发送端将每个包都封装成固定的长度，比如 100 字节大小。如果不足 100 字节可通过补 0 或空等进行填充到指定长度；&lt;/li>
&lt;li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n 进行合并；例如，FTP 协议；&lt;/li>
&lt;li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；&lt;/li>
&lt;li>通过自定义协议进行粘包和拆包的处理。&lt;/li>
&lt;/ul>
&lt;h2 id="重传机制">重传机制
&lt;/h2>&lt;h3 id="超时重传以时间驱动">超时重传（以时间驱动）
&lt;/h3>&lt;p>RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。&lt;/p>
&lt;p>超时重传时间是以 RTO(Retransmission Timeout 超时重传时间)表示。&lt;/p>
&lt;p>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差。&lt;/p>
&lt;p>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。&lt;/p>
&lt;p>根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。&lt;/p>
&lt;h3 id="快速重传以数据驱动">快速重传（以数据驱动）
&lt;/h3>&lt;p>发送方发出了 1，2，3，4，5 份数据:
第一份 Seq1 先送到了，于是就 Ack 回 2;结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2;后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2 因为 Seq2 还是没有收到。&lt;/p>
&lt;p>发送端收到了三个 Ack =2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。&lt;/p>
&lt;p>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6。&lt;/p>
&lt;p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。&lt;/p>
&lt;p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。&lt;/p>
&lt;h3 id="sack-方法">SACK 方法
&lt;/h3>&lt;p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。&lt;/p>
&lt;h3 id="duplicate-sack-方法">Duplicate SACK 方法
&lt;/h3>&lt;p>Duplicate SACK 又称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。&lt;/p>
&lt;h2 id="滑动窗口">滑动窗口
&lt;/h2>&lt;p>TCP 滑动窗口是一种流量控制机制，用于管理在发送端和接收端之间传输的数据量，其基本原理如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>发送窗口&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>发送端维护一个窗口，表示允许发送但尚未收到确认的数据范围。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>接收窗口&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>接收端根据自身缓冲区大小，通过 ACK 报文告知发送端当前可接收的数据量，这就是接收窗口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>窗口滑动&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当发送端收到 ACK 确认后，窗口向前移动，释放已确认的数据位置，从而可以继续发送新的数据。&lt;/li>
&lt;li>这种“滑动”过程确保了数据的连续传输，同时防止发送端发送过多数据导致接收端溢出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="流量控制">流量控制
&lt;/h2>&lt;p>TCP 流量控制是一种确保数据传输双方保持平衡的机制。其主要目标是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>保护接收端&lt;/strong>：避免发送速率超过接收端处理能力，防止数据丢失或缓冲区溢出。&lt;/li>
&lt;li>&lt;strong>动态调整数据流&lt;/strong>：通过接收端反馈的窗口大小，发送端能够动态决定一次可以发送多少数据，确保高效且稳定的数据传输。&lt;/li>
&lt;/ul>
&lt;p>简单来说，TCP 流量控制就是通过交换窗口大小信息，使发送方根据接收方的当前处理能力来决定发送数据的速率，从而保持整个数据传输过程的可靠性和高效性。&lt;/p>
&lt;h2 id="拥塞控制">拥塞控制
&lt;/h2>&lt;p>TCP 拥塞控制是一种确保网络稳定和高效的数据传输机制，其主要目标是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>预防网络拥塞&lt;/strong>：通过检测数据包丢失、延迟增大等现象，判断网络是否发生拥堵。&lt;/li>
&lt;li>&lt;strong>动态调整发送速率&lt;/strong>：在网络出现拥堵迹象时，降低发送窗口大小或发送速率；当网络状况改善时，逐步增加速率。&lt;/li>
&lt;li>&lt;strong>维护传输效率&lt;/strong>：在避免网络拥堵的同时，尽可能利用可用带宽实现高效的数据传输。&lt;/li>
&lt;/ul>
&lt;p>简单来说，TCP 拥塞控制就是通过动态调整数据发送速率来应对网络拥堵，确保数据传输既稳定又高效。&lt;/p></description></item><item><title>关于HTTP/HTTPS的笔记</title><link>https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ehttp/https%E7%9A%84%E7%AC%94%E8%AE%B0/</link><pubDate>Thu, 20 Feb 2025 12:26:09 +0800</pubDate><guid>https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ehttp/https%E7%9A%84%E7%AC%94%E8%AE%B0/</guid><description>&lt;h2 id="前言">前言
&lt;/h2>&lt;p>关于 HTTP/HTTPS 的笔记。&lt;/p>
&lt;p>希望这些笔记不仅能帮助自己系统梳理知识，也能为其他学习计算机网络的朋友提供借鉴。&lt;/p>
&lt;p>PS 不定时更新，欢迎讨论区留言。&lt;/p>
&lt;h2 id="http-是什么">HTTP 是什么？
&lt;/h2>&lt;p>HTTP 是一个在计算机世界里专门在【两点】之间【传输】文字、图片、音频、视频等【超文本】数据的【约定和规范】。&lt;/p>
&lt;h2 id="常见的-http-状态码">常见的 HTTP 状态码
&lt;/h2>&lt;p>HTTP 状态码通常分为五大类：1xx、2xx、3xx、4xx 和 5xx，每一类代表一种响应类别。以下是一些常见的状态码：&lt;/p>
&lt;h3 id="1xx信息性状态码">1xx（信息性状态码）
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>100 Continue&lt;/strong>：继续发送请求的剩余部分。&lt;/li>
&lt;li>&lt;strong>101 Switching Protocols&lt;/strong>：服务器正在根据客户端的请求切换协议。&lt;/li>
&lt;/ul>
&lt;h3 id="2xx成功状态码">2xx（成功状态码）
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>200 OK&lt;/strong>：请求成功，服务器返回请求的数据。&lt;/li>
&lt;li>&lt;strong>201 Created&lt;/strong>：请求成功，服务器创建了新的资源。&lt;/li>
&lt;li>&lt;strong>202 Accepted&lt;/strong>：请求已接受，但处理尚未完成。&lt;/li>
&lt;li>&lt;strong>204 No Content&lt;/strong>：请求成功，但没有内容返回。&lt;/li>
&lt;/ul>
&lt;h3 id="3xx重定向状态码">3xx（重定向状态码）
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>301 Moved Permanently&lt;/strong>：请求的资源已被永久移动到新位置。&lt;/li>
&lt;li>&lt;strong>302 Found&lt;/strong>：请求的资源临时从不同的 URI 响应。&lt;/li>
&lt;li>&lt;strong>304 Not Modified&lt;/strong>：资源未修改，客户端可继续使用缓存的版本。&lt;/li>
&lt;/ul>
&lt;h3 id="4xx客户端错误状态码">4xx（客户端错误状态码）
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>400 Bad Request&lt;/strong>：请求语法错误，服务器无法理解。&lt;/li>
&lt;li>&lt;strong>401 Unauthorized&lt;/strong>：请求要求身份验证。&lt;/li>
&lt;li>&lt;strong>403 Forbidden&lt;/strong>：服务器拒绝请求。&lt;/li>
&lt;li>&lt;strong>404 Not Found&lt;/strong>：请求的资源不存在。&lt;/li>
&lt;li>&lt;strong>405 Method Not Allowed&lt;/strong>：请求方法不被允许。&lt;/li>
&lt;li>&lt;strong>408 Request Timeout&lt;/strong>：请求超时。&lt;/li>
&lt;/ul>
&lt;h3 id="5xx服务器错误状态码">5xx（服务器错误状态码）
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>500 Internal Server Error&lt;/strong>：服务器内部错误，无法完成请求。&lt;/li>
&lt;li>&lt;strong>501 Not Implemented&lt;/strong>：服务器不支持请求的功能。&lt;/li>
&lt;li>&lt;strong>502 Bad Gateway&lt;/strong>：作为网关或代理的服务器从上游服务器接收到无效响应。&lt;/li>
&lt;li>&lt;strong>503 Service Unavailable&lt;/strong>：服务器当前无法处理请求，通常是由于过载或维护。&lt;/li>
&lt;li>&lt;strong>504 Gateway Timeout&lt;/strong>：网关或代理服务器未及时从上游服务器收到响应。&lt;/li>
&lt;/ul>
&lt;h2 id="get-与-post">GET 与 POST
&lt;/h2>&lt;p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。&lt;/p>
&lt;p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。&lt;/p>
&lt;h2 id="http-各个版本比较">HTTP 各个版本比较
&lt;/h2>&lt;p>HTTP（超文本传输协议）是 Web 通信的基础协议，随着互联网的发展，HTTP 协议经过多次演变。本文档将介绍常见的 HTTP 版本及其主要特性和区别。&lt;/p>
&lt;h3 id="http09">HTTP/0.9
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>简介&lt;/strong>：是 HTTP 最早的版本，设计非常简单。&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>：
&lt;ul>
&lt;li>只支持 GET 方法。&lt;/li>
&lt;li>不支持消息头和状态码。&lt;/li>
&lt;li>主要用于获取简单的 HTML 文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>限制&lt;/strong>：功能非常受限，无法应对复杂的需求，如状态管理或内容协商。&lt;/li>
&lt;/ul>
&lt;h3 id="http10">HTTP/1.0
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>简介&lt;/strong>：HTTP/1.0 在 1996 年作为 RFC 1945 发布，是对 HTTP/0.9 的扩展。&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>：
&lt;ul>
&lt;li>支持多种请求方法，如 GET、POST、HEAD。&lt;/li>
&lt;li>引入了状态码和响应头，使得响应内容更加丰富。&lt;/li>
&lt;li>每个请求后通常会关闭连接（非持久连接）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>限制&lt;/strong>：
&lt;ul>
&lt;li>每次请求都需建立新的 TCP 连接，导致效率较低。&lt;/li>
&lt;li>不支持持久连接，无法处理多个请求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="http11">HTTP/1.1
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>简介&lt;/strong>：HTTP/1.1 在 1997 年发布（RFC 2068），经过多次修订，是目前应用最广泛的版本。&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>：
&lt;ul>
&lt;li>支持持久连接（Connection: keep-alive），可以在同一连接上发送多个请求。&lt;/li>
&lt;li>支持分块传输编码（chunked transfer encoding），使得数据流能够动态生成。&lt;/li>
&lt;li>引入了更多的请求方法和头部字段，如 OPTIONS、PUT、DELETE 等。&lt;/li>
&lt;li>支持管道化（pipelining），即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体响应时间。但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应，如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」，所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>：相比于 HTTP/1.0, 在性能和灵活性上都有显著提升。&lt;/li>
&lt;/ul>
&lt;h3 id="http2">HTTP/2
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>简介&lt;/strong>：HTTP/2 在 2015 年作为 RFC 7540 发布，主要目标是提高性能和减少延迟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>特点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基于二进制协议而不是文本协议，提高了解析效率和可靠性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持多路复用（multiplexing），在单一 TCP 连接内同时发送多个请求和响应，减少了连接建立的开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用头部压缩（HPACK：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了），降低请求和响应头的传输量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持服务器推送（Server Push），服务器可以主动推送资源到客户端，以减少等待时间。&lt;/p>
&lt;p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而在 TCP 这一层。HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="http3">HTTP/3
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>简介&lt;/strong>：HTTP/3 是 HTTP 协议的最新版本，目前处于快速发展阶段。HTTP/3 基于 QUIC 协议构建。&lt;/p>
&lt;p>HTTP/1.1 中的管道(pipeline)虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后，才能处理下一个请求，这属于 HTTP 层队头阻塞。HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。HTTP/2 队头阻塞的问题是因为 TCP，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP!&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>特点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用 QUIC 传输协议，基于 UDP 而非传统的 TCP。QUIC 结合了 TLS/SSL 加密功能，从而提高了安全性和连接建立速度。&lt;/li>
&lt;li>支持多路复用，不存在 TCP 队头阻塞问题，即使某个流遇到问题也不会影响其他流。&lt;/li>
&lt;li>连接恢复更快：在网络环境变化时（如网络切换），HTTP/3 能够更好地保持会话连续性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>改进&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>提供了更低的延迟、更快的连接建立速度以及更加可靠的传输体验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>HTTP 版本&lt;/th>
&lt;th>特点或改进&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>HTTP/0.9&lt;/strong>&lt;/td>
&lt;td>最基础，仅支持 GET 请求，功能极其简单。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>HTTP/1.0&lt;/strong>&lt;/td>
&lt;td>引入状态码和头部，但每次请求都关闭连接。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>HTTP/1.1&lt;/strong>&lt;/td>
&lt;td>支持持久连接和多种请求方法，大大提高了传输效率。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>HTTP/2&lt;/strong>&lt;/td>
&lt;td>通过二进制传输、多路复用、头部压缩和服务器推送等特性进一步提升性能。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>HTTP/3&lt;/strong>&lt;/td>
&lt;td>采用 QUIC 协议，改善了连接建立和多路复用的性能，尤其在高延迟或不稳定网络环境下表现优异。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="http-与-https">HTTP 与 HTTPS
&lt;/h2>&lt;p>HTTP（超文本传输协议）和 HTTPS（安全超文本传输协议）是用于客户端与服务器之间通信的两种协议。它们在功能上相似，但在安全性和数据传输方式上存在重要区别。&lt;/p>
&lt;h3 id="http">HTTP
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>定义&lt;/strong>：HTTP 是一种无状态、无连接的应用层协议，用于传输超文本（如 HTML）。&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>无加密&lt;/strong>：数据以明文形式传输，易受到窃听和中间人攻击。&lt;/li>
&lt;li>&lt;strong>端口&lt;/strong>：默认使用 80 端口。&lt;/li>
&lt;li>&lt;strong>性能&lt;/strong>：由于传输简单，开销较小，但安全性不足。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：适用于对数据安全性要求不高的场景或内部网络环境中。&lt;/li>
&lt;/ul>
&lt;h3 id="https">HTTPS
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>定义&lt;/strong>：HTTPS 是基于 HTTP 协议并结合 TLS/SSL 加密层的安全传输协议。&lt;/li>
&lt;li>&lt;strong>特点&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>加密传输&lt;/strong>：通过 TLS/SSL 对数据进行加密，保护数据传输过程中不被窃取或篡改。&lt;/li>
&lt;li>&lt;strong>身份验证&lt;/strong>：服务器需要通过数字证书进行身份验证，增强了信任度。&lt;/li>
&lt;li>&lt;strong>数据完整性&lt;/strong>：提供数据完整性校验，可以检测数据在传输中的任何异常修改。&lt;/li>
&lt;li>&lt;strong>端口&lt;/strong>：默认使用 443 端口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：适用于要求高安全性的数据传输场景，如电子商务、在线银行、用户登录等。&lt;/li>
&lt;/ul>
&lt;h3 id="http-与-https-的比较">HTTP 与 HTTPS 的比较
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>特性&lt;/th>
&lt;th>HTTP&lt;/th>
&lt;th>HTTPS&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>加密&lt;/td>
&lt;td>无加密，数据明文传输&lt;/td>
&lt;td>使用 TLS/SSL 加密，保障数据安全&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>默认端口&lt;/td>
&lt;td>80&lt;/td>
&lt;td>443&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据安全性&lt;/td>
&lt;td>低，易受中间人攻击和窃听&lt;/td>
&lt;td>高，数据在传输过程中受到保护&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>网站信任度&lt;/td>
&lt;td>通常用于公开信息传输，可以用在内容分发等场景&lt;/td>
&lt;td>增强了用户信任，搜索引擎排名也通常给予 HTTPS 网站更多优势&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>实施成本&lt;/td>
&lt;td>实现简单，无需额外配置&lt;/td>
&lt;td>需要购买或申请 TLS/SSL 证书，配置相对复杂&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="tls-握手的简单描述">TLS 握手的简单描述
&lt;/h3>&lt;p>&lt;img src="https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ehttp/https%E7%9A%84%E7%AC%94%E8%AE%B0/https.png"
width="1635"
height="873"
srcset="https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ehttp/https%E7%9A%84%E7%AC%94%E8%AE%B0/https_hu_f0843c2b293ae3b9.png 480w, https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Ehttp/https%E7%9A%84%E7%AC%94%E8%AE%B0/https_hu_3df54ea33a8038c4.png 1024w"
loading="lazy"
alt="blibli 技术蛋老师视频截图"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="449px"
>
&lt;a class="link" href="https://www.bilibili.com/video/BV1KY411x7Jp/?share_source=copy_web&amp;amp;vd_source=3b63c0fccbecf1d3b621910b49a7a8b3" title="blibli 技术蛋老师https视频"
target="_blank" rel="noopener"
>blibli 技术蛋老师 https 视频&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>ClientHello&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端发起连接，发送 &lt;code>ClientHello&lt;/code> 消息。&lt;/li>
&lt;li>消息中包含客户端支持的 TLS 版本、加密套件以及一个随机数（Client Random）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ServerHello 与服务器认证&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>服务器收到 &lt;code>ClientHello&lt;/code> 后，回复 &lt;code>ServerHello&lt;/code> 消息，确认 TLS 版本和加密套件，并提供自己的随机数（Server Random）。&lt;/li>
&lt;li>同时，服务器发送数字证书（Certificate），用于证明其身份（可选：还会发送密钥交换参数）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ClientKeyExchange&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端验证服务器的证书后，生成一个预主密钥，并使用服务器的公钥对其进行加密后发送给服务器。&lt;/li>
&lt;li>双方利用预主密钥以及交换的随机数计算出对称加密会话密钥。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Finished&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>双方分别发送 &lt;code>Finished&lt;/code> 消息。这些消息包含双方所有握手数据的摘要，用于验证握手过程的完整性。&lt;/li>
&lt;li>握手完成后，后续的通信将使用协商的对称密钥加密传输数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="https-中对称加密与非对称加密的简单描述解决窃听风险">HTTPS 中对称加密与非对称加密的简单描述（解决窃听风险）
&lt;/h3>&lt;p>HTTPS 通过结合使用非对称加密和对称加密来确保通信的安全性。下面简单描述这两种加密方式在 HTTPS 中的作用：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>非对称加密&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用公钥和私钥进行加密和解密。&lt;/li>
&lt;li>在 TLS 握手阶段，客户端使用服务器的公钥加密预主密钥，服务器使用私钥来解密，从而安全地交换密钥。&lt;/li>
&lt;li>主要用于身份验证和密钥交换，虽然安全性高，但计算较慢。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>对称加密&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用相同的密钥进行加密和解密。&lt;/li>
&lt;li>TLS 握手完成后，客户端和服务器使用协商好的会话密钥对数据进行加密传输。&lt;/li>
&lt;li>速度快，适用于大量数据的加密，但依赖密钥的安全交换。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="https-中的摘要算法与数字签名的简单描述解决篡改风险">HTTPS 中的摘要算法与数字签名的简单描述（解决篡改风险）
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>摘要算法&lt;/strong>：&lt;br>
将任意长度的数据转换为固定长度的哈希值（或称消息摘要），其关键特点是单向性不可逆。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：用于检测数据在传输过程中是否被篡改。&lt;/li>
&lt;li>&lt;strong>常见算法&lt;/strong>：例如 SHA-256，适用于确保数据完整性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数字签名&lt;/strong>：&lt;br>
结合摘要算法与非对称加密技术，实现对数据来源和完整性的验证。&lt;/p>
&lt;p>公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解
密的，只有持有私钥的人，才能解密出实际的内容;&lt;/p>
&lt;p>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常
解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>过程&lt;/strong>：先对数据使用摘要算法生成哈希值，然后使用发送方的私钥对该哈希值进行加密，从而得到数字签名；接收方使用发送方的公钥解密签名，并与自己计算的哈希值进行比对。&lt;/li>
&lt;li>&lt;strong>作用&lt;/strong>：验证数据的真实性及防止数据被篡改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="https-数字证书的简单描述解决冒充风险">HTTPS 数字证书的简单描述（解决冒充风险）
&lt;/h3>&lt;p>HTTPS 数字证书是保障互联网通信安全的重要组成部分，用于验证服务器的身份并确保数据传输过程中的加密通信安全。&lt;/p>
&lt;p>数字证书是一种电子文档，其中包含以下信息：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>持有者信息&lt;/strong>：如服务器的名称、域名及其他标识信息。&lt;/li>
&lt;li>&lt;strong>公钥&lt;/strong>：用于加密数据或验证数字签名的公钥。&lt;/li>
&lt;li>&lt;strong>颁发机构信息&lt;/strong>：数字证书由受信任的第三方（称为证书颁发机构，CA）签发，确保证书的真实性。&lt;/li>
&lt;li>&lt;strong>有效期&lt;/strong>：证书的开始日期和截止日期。&lt;/li>
&lt;li>&lt;strong>数字签名&lt;/strong>：由证书颁发机构使用其私钥生成的签名，用于验证证书内容是否被篡改。&lt;/li>
&lt;/ul>
&lt;p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。&lt;/p>
&lt;h3 id="https-是否可能被中间人截获">HTTPS 是否可能被中间人截获？
&lt;/h3>&lt;p>HTTPS 设计的主要目标之一是防止中间人攻击（MITM）。通过使用 TLS/SSL 加密，HTTPS 确保了通信双方之间的数据在传输过程中是加密的，任何试图拦截的数据都难以解密或篡改。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>证书验证与信任链&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>浏览器和客户端会验证服务器提供的数字证书，确保其由受信任的证书颁发机构（CA）签发。如果验证通过，客户端就会信任与服务器的连接。&lt;/li>
&lt;li>如果攻击者能够伪造有效的证书或成功欺骗客户端（例如通过用户忽略警告），才有可能进行中间人攻击。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>加密保护&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>正确配置和使用 HTTPS 时，即使数据被中间人拦截，由于数据是加密的，攻击者也无法轻易解密和修改数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>潜在风险&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>配置错误：如果服务器使用了弱加密算法、过期或错误配置的证书，可能会降低安全性，使攻击者有机可乘。&lt;/li>
&lt;li>CA 安全问题：一旦证书颁发机构（CA）受到攻击或存在漏洞，攻击者也可能利用伪造证书进行攻击。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="https-中-rsa-与-ecdhe-简单比较">HTTPS 中 RSA 与 ECDHE 简单比较
&lt;/h3>&lt;p>下表简单对比了 HTTPS 中使用的 RSA 与 ECDHE 两种密钥交换方式的主要区别：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方面&lt;/th>
&lt;th>RSA&lt;/th>
&lt;th>ECDHE&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>密钥交换方式&lt;/td>
&lt;td>用 RSA 公钥加密预主密钥&lt;/td>
&lt;td>基于椭圆曲线 Diffie-Hellman 临时密钥交换&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>前向保密性&lt;/td>
&lt;td>无前向保密性；私钥泄露可能导致历史会话泄密&lt;/td>
&lt;td>提供前向保密性；每次会话生成新的临时密钥&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>计算效率&lt;/td>
&lt;td>依赖较长密钥，加密解密计算量大&lt;/td>
&lt;td>密钥较短，计算更高效&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>安全性&lt;/td>
&lt;td>基于大数分解难题，量子计算威胁较高&lt;/td>
&lt;td>基于椭圆曲线离散对数问题，安全性更好&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="http11-优化思路">HTTP/1.1 优化思路？
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二个思路是，减少 HTTP 请求的次数，有以下的方法:&lt;/p>
&lt;ul>
&lt;li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数。&lt;/li>
&lt;li>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗。&lt;/li>
&lt;li>按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="为什么需要-websocket">为什么需要 WebSocket？
&lt;/h3>&lt;p>虽然 HTTP 协议已经在互联网应用中得到了广泛使用，但其设计理念是基于请求-响应模型，适合单向通信，即客户端发起请求，服务器返回响应。这种模型存在以下局限性：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无状态连接&lt;/strong>：HTTP 是无状态的，每次请求都要重新建立连接，无法直接保持长时间的双向通信。&lt;/li>
&lt;li>&lt;strong>单向通信&lt;/strong>：服务器不能主动向客户端推送数据，所有通信都必须由客户端发起请求。&lt;/li>
&lt;li>&lt;strong>高延迟&lt;/strong>：频繁建立和断开连接会带来额外的延迟和资源开销，尤其在实时应用场景下不够高效。&lt;/li>
&lt;/ul>
&lt;p>为了解决这些局限性，WebSocket 协议应运而生，其主要优势包括：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>双向通信&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>WebSocket 建立了一个持久连接，允许数据在客户端和服务器之间双向实时传输，不需要每次都重新建立连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>低延迟&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一旦建立连接，数据交换无需重复 HTTP 请求头，降低了通信延迟，适合要求实时更新的应用场景，如在线游戏、金融交易、聊天应用等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>更高效的资源利用&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>持久连接减少了频繁的连接建立和关闭开销，有助于减轻服务器压力，同时也降低了网络带宽消耗。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>更灵活的应用场景&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>WebSocket 可以实现实时数据推送，服务器可以主动发送数据给客户端，非常适合实现实时监控、协同编辑等需要快速交互的应用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item></channel></rss>