<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TCP/UDP on ltlylfunBlog</title><link>https://blog.ltlyl.fun/tags/tcp/udp/</link><description>Recent content in TCP/UDP on ltlylfunBlog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 20 Feb 2025 16:16:09 +0800</lastBuildDate><atom:link href="https://blog.ltlyl.fun/tags/tcp/udp/index.xml" rel="self" type="application/rss+xml"/><item><title>关于TCP/UDP的笔记</title><link>https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/</link><pubDate>Thu, 20 Feb 2025 16:16:09 +0800</pubDate><guid>https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/</guid><description>&lt;h2 id="前言">前言
&lt;/h2>&lt;p>关于 TCP/UDP 的笔记。&lt;/p>
&lt;p>希望这些笔记不仅能帮助自己系统梳理知识，也能为其他学习计算机网络的朋友提供借鉴。&lt;/p>
&lt;p>PS 不定时更新，欢迎讨论区留言。&lt;/p>
&lt;h2 id="什么是-tcp">什么是 TCP？
&lt;/h2>&lt;p>TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>面向连接&lt;/strong>&lt;br>
在发送数据之前，通信双方会先通过一个称为“三次握手”（3-way handshake）的过程建立一条可靠的传输连接。只有连接建立完成后，数据传输才能开始。是一对一的，不能像 UDP 一样一对多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可靠传输&lt;/strong>&lt;br>
TCP 使用数据确认（ACK）、超时重传、重复确认（Duplicate ACK）等机制，确保数据包能够按顺序、完整地到达接收端。如果发生数据丢失或出错，TCP 能够自动进行重传，保证传输的可靠性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>面向字节流&lt;/strong>&lt;br>
TCP 将数据视为连续的字节流，而不是独立的数据包。这意味着在应用层数据的边界需要进行额外管理，例如通过消息分隔符或固定长度来标识每个独立的消息。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="tcp-与-udp-对比表">TCP 与 UDP 对比表
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>方面&lt;/strong>&lt;/th>
&lt;th>&lt;strong>TCP&lt;/strong>&lt;/th>
&lt;th>&lt;strong>UDP&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>面向连接&lt;/td>
&lt;td>是，需要建立连接（三次握手）后才能进行数据传输&lt;/td>
&lt;td>否，无连接，数据直接发送&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据可靠性&lt;/td>
&lt;td>高，具备数据确认、重传机制、累积确认和错误校验等措施，确保数据准确无误到达&lt;/td>
&lt;td>低，无内建确认和重传机制，数据可能丢失或乱序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据顺序&lt;/td>
&lt;td>保证按发送顺序到达&lt;/td>
&lt;td>不保证顺序，数据包独立传输&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>流量控制&lt;/td>
&lt;td>采用滑动窗口机制，根据接收方缓冲区大小动态控制数据发送速率&lt;/td>
&lt;td>无，发送数据完全由应用层控制，可能导致接收端被淹没&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>拥塞控制&lt;/td>
&lt;td>有，使用慢启动、拥塞避免、快速重传与快速恢复等算法，动态调整发送速率以应对网络拥塞&lt;/td>
&lt;td>无，不具备拥塞控制，可能在网络繁忙时频繁丢包&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>错误检测与恢复&lt;/td>
&lt;td>有，通过校验和及确认机制检测错误，并通过重传恢复丢失的数据&lt;/td>
&lt;td>仅有基本的校验和，不能进行错误恢复&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>头部开销&lt;/td>
&lt;td>较大，TCP 头部通常为 20 字节或以上，包含丰富的控制信息&lt;/td>
&lt;td>较小，仅 8 字节，结构简单&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>连接管理&lt;/td>
&lt;td>复杂，需经过三次握手建立连接及四次挥手断开连接，带来额外延时和资源开销&lt;/td>
&lt;td>简单，无需连接建立和断开，适用于快速传输&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>实时性&lt;/td>
&lt;td>相对较低，其可靠性保障和拥塞控制可能导致延迟上升，通常不适用于对延迟极度敏感的场景&lt;/td>
&lt;td>高，延迟低，适合实时视频、在线游戏、VoIP 等对时效性要求较高的应用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>适用场景&lt;/td>
&lt;td>文件传输、网页浏览、电子邮件、数据库通信等需要高可靠性和数据顺序保证的应用&lt;/td>
&lt;td>实时通讯、视频会议、在线游戏、DNS 查询、流媒体传输等可以容忍部分数据丢失，但要求低延迟的场景&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="tcp-和-udp-可以使同个端吗">TCP 和 UDP 可以使⽤同⼀个端⼝吗？
&lt;/h2>&lt;p>可以的。&lt;/p>
&lt;p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。&lt;/p>
&lt;p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。&lt;/p>
&lt;p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。&lt;/p>
&lt;p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。&lt;/p>
&lt;h2 id="序列号seq和初始序列号isn">序列号(SEQ)和初始序列号(ISN)
&lt;/h2>&lt;p>序列号，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP
是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋
予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32
位的无符号数，因此在到达 4G 之后再循环回到 0。&lt;/p>
&lt;p>初始序列号，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时
钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位
的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时。&lt;/p>
&lt;h2 id="tcp-三次握手过程">TCP 三次握手过程
&lt;/h2>&lt;p>TCP 三次握手（Three-Way Handshake）是建立一个可靠的 TCP 连接的过程，通过交换控制信息来初始化连接参数。下面是详细的步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>第一次握手（SYN）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端向服务器发送一个带有 SYN 标志的报文段，该报文段包含客户端选择的初始序列号（ISN）。&lt;/li>
&lt;li>该报文段表示客户端希望与服务器建立连接。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: SYN, Seq = x
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二次握手（SYN-ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>服务器收到客户端的 SYN 后，发送一个包含 SYN 和 ACK 标志的报文段给客户端。&lt;/li>
&lt;li>该报文段中，ACK 用来确认收到客户端的 SYN（Ack = x + 1），同时服务器也选择一个初始序列号（ISN = y）来建立自己的连接参数。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">服务器 → 客户端: SYN, ACK, Seq = y, Ack = x + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三次握手（ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端在收到服务器的 SYN-ACK 后，再发送一个只带 ACK 标志的报文段，作为对服务器响应的确认。&lt;/li>
&lt;li>该报文段中的 ACK 用来确认收到服务器的 SYN（Ack = y + 1）。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: ACK, Seq = x + 1, Ack = y + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>当服务器收到这个 ACK 后，双方就建立了一个可靠的 TCP 连接，可以进行后续数据传输了。&lt;/p>
&lt;h2 id="为什么需要三次握手而不是两次或四次">为什么需要三次握手，而不是两次或四次？
&lt;/h2>&lt;p>「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双方资源的浪费，也⽆法可靠的同步双⽅序列号。&lt;/p>
&lt;p>「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。&lt;/p>
&lt;h2 id="tcp-握手丢失情况">TCP 握手丢失情况
&lt;/h2>&lt;h3 id="tcp-第一次握手丢失的情况">TCP 第一次握手丢失的情况
&lt;/h3>&lt;p>当第一次握手丢失时，TCP 将通过重传策略来尝试恢复连接，但如果问题持续存在，连接将建立失败并反馈错误信息给应用程序。&lt;/p>
&lt;h3 id="tcp-第二次握手丢失的情况">TCP 第二次握手丢失的情况
&lt;/h3>&lt;p>当第二次握手丢失了，客户端和服务端都会重传。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由内核参数决定。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由内核参数决定。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tcp-第三次握手丢失的情况">TCP 第三次握手丢失的情况
&lt;/h3>&lt;p>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。直到收到第三次握⼿，或者达到最⼤重传次数。&lt;/p>
&lt;h2 id="tcp-四次挥手过程">TCP 四次挥手过程
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>第一次挥手（FIN）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端在没有数据发送后，向服务器发送一个带有 FIN 标志的报文段，以指示客户端不再有数据要发送。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: FIN, Seq = u
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二次挥手（ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>服务器收到客户端的 FIN 报文段后，立即发送一个 ACK 报文段作为确认，表明已接收到客户端停止发送数据的请求。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">服务器 → 客户端: ACK, Seq = v, Ack = u + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>此时，服务器可能仍有未传输完的数据，故数据传输方向上尚未完全关闭。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三次挥手（FIN）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当服务器完成剩余数据的传输后，会向客户端发送一个带有 FIN 标志的报文段，通知客户端服务器也没有数据要发送了，准备关闭连接。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">服务器 → 客户端: FIN, Seq = w
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第四次挥手（ACK）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段以确认收到服务器关闭连接的请求。&lt;/li>
&lt;li>表示形式：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">客户端 → 服务器: ACK, Seq = u + 1, Ack = w + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="为什么-tcp-挥手需要四次">为什么 TCP 挥手需要四次？
&lt;/h2>&lt;p>TCP 使用四次挥手断开连接，主要原因在于 TCP 连接是全双工的，也就是数据传输在两个方向上是独立的。在断开连接时，每个方向的数据传输都需要单独关闭。下面详细解释这一过程以及四次挥手的必要性：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>单向关闭&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当一方准备结束数据发送时，它只关闭自己的发送通道，但仍可接收数据。&lt;/li>
&lt;li>例如，当客户端发送一个 FIN 时，它表示自己没有数据要发送了，但仍然可以接收服务器的数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>独立的确认&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对于第一次 FIN（例如客户端发送的 FIN），服务器需要发送一个 ACK 来确认已经收到关闭请求。这只是对单个方向（客户端到服务器）的关闭确认。&lt;/li>
&lt;li>接下来，服务器完成自身数据发送后，也需要发送 FIN 来关闭其发送通道，客户端再对其进行确认。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>为何需要四次&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>第一步（客户端 FIN）：客户端通知服务器“我已经没有数据要发送了”。&lt;/li>
&lt;li>第二步（服务器 ACK）：服务器确认客户端的 FIN，并告知已接收，但此时仍可继续发送数据给客户端。&lt;/li>
&lt;li>第三步（服务器 FIN）：当服务器也结束发送数据后，它通知客户端“我也没有数据要发送了”。&lt;/li>
&lt;li>第四步（客户端 ACK）：客户端确认服务器的关闭请求，整个连接才能完全关闭。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可靠的连接终止&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>四次挥手确保了双方在断开连接前都能完成数据传输与确认，避免数据丢失。&lt;/li>
&lt;li>这种设计使得双方可以独立地结束各自的数据传输，从而达到安全、可靠地断开连接的目的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="什么情况会出现三次挥手">什么情况会出现三次挥手？
&lt;/h2>&lt;p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK(默认情
况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制)」，那么第二和第三
次挥手就会合并传输，这样就出现了三次挥手。&lt;/p>
&lt;h2 id="tcp-挥手丢失情况">TCP 挥手丢失情况
&lt;/h2>&lt;h3 id="tcp-第一次挥手丢失的情况">TCP 第一次挥手丢失的情况
&lt;/h3>&lt;p>当 TCP 第一次挥手的 FIN 报文丢失时，连接不会被立即关闭。主动关闭方会依赖重传机制来确保 FIN 最终传达到对方，一旦双方完成重传和确认，连接才会进入正常的终止流程。&lt;/p>
&lt;h3 id="tcp-第二次挥手丢失的情况">TCP 第二次挥手丢失的情况
&lt;/h3>&lt;p>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。&lt;/p>
&lt;h3 id="tcp-第三次挥手丢失的情况">TCP 第三次挥手丢失的情况
&lt;/h3>&lt;p>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。&lt;/p>
&lt;p>客户端因为是通过 close 函数关闭连接的，处于 FIN WAIT 2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手(FIN 报文)，那么客户端就会断开连接。&lt;/p>
&lt;h3 id="tcp-第四次挥手丢失的情况">TCP 第四次挥手丢失的情况
&lt;/h3>&lt;p>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2，达到了最大重传次数，于是再等待一段时间(时间为上一次超时时间的 2 倍)，如果还是没能收到客户端的第四次挥手(ACK 报文)，那么服务端就会断开连接。&lt;/p>
&lt;p>客户端在收到第三次挥手后，就会进入 TIME WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手(FIN 报文)后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。&lt;/p>
&lt;h2 id="为什么需要-time_wait-状态">为什么需要 TIME_WAIT 状态？
&lt;/h2>&lt;p>防止历史连接中的数据，被后面相同四元组的连接错误的接收。&lt;/p>
&lt;p>保证「被动关闭连接」的一方，能被正确的关闭。&lt;/p>
&lt;h2 id="为什么每次建立-tcp-连接时初始化的序列号都要求不一样">为什么每次建立 TCP 连接时，初始化的序列号都要求不一样？
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>防止旧数据干扰&lt;/strong>&lt;br>
如果使用固定或者可预测的序列号，网络中可能还残留有上一次连接的数据包，在新连接建立后，这些旧数据包可能会被误认为是当前连接的数据，从而导致数据混乱或连接异常。选择唯一的 ISN 可以避免这种数据干扰问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>确保数据流正确排序&lt;/strong>&lt;br>
TCP 是一个面向字节流的协议，双方通过序列号来组织和排序数据。当每次连接的序列号都不相同时，可以确保即使出现重传或者网络延迟，接收方也能正确地将数据包按正确的顺序进行排序和重组。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>增强安全性&lt;/strong>&lt;br>
可预测的序列号可能给攻击者提供利用的机会，例如 TCP 序列号预测攻击。因此，每次连接都使用一个不容易预测的初始序列号，可以有效提升连接的安全性，降低恶意攻击的风险。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>区分不同连接&lt;/strong>&lt;br>
在同一对主机之间可能会在短时间内建立多个 TCP 连接。通过为每个连接选择不同的 ISN，可以帮助系统区分并管理这些连接，防止连接状态混淆。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="什么是-mtu">什么是 MTU
&lt;/h2>&lt;p>最大传输单元（英语：Maximum Transmission Unit，缩写 MTU）是指数据链路层上面所能通过的最大数据包大小（以字节为单位）。&lt;/p>
&lt;h2 id="什么是-mss">什么是 MSS？
&lt;/h2>&lt;p>最大分段大小（Maximum Segment Size）是传输控制协议的一个参数，以字节数定义一个计算机或通信设备所能接受的分段的最大数据量。 它并不会计算 TCP 或 IP 协议头的大小。即最大传输单元除去信头后的最大数据量。&lt;/p>
&lt;h2 id="为什么-tcp-层需要-mss">为什么 TCP 层需要 MSS？
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>降低 IP 分片的开销和风险&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分片开销&lt;/strong>：IP 分片不仅增加了每个数据包在网络上传输时的负担，还会影响路由器和接收主机的处理效率。每个分片都需要单独处理，如果分片过多，会导致额外的延时和资源消耗。&lt;/li>
&lt;li>&lt;strong>分片丢失问题&lt;/strong>：如果 IP 分片中的任一碎片丢失，整个数据包都必须重新传输。而且某些网络设备可能不支持 IP 分片或安全策略会丢弃分片，导致传输失败。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>提高传输效率与可靠性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>匹配底层网络 MTU&lt;/strong>：TCP 在连接建立时协商并计算对端的 MSS，通常依据路径 MTU（Path MTU）来计算。这样可以确保 TCP 报文段在封装进 IP 数据报之后，不会超出最低链路的 MTU，从而避免触发 IP 分片。&lt;/li>
&lt;li>&lt;strong>优化数据传输&lt;/strong>：合理的 MSS 可以使得每个 TCP 报文段刚好适应底层网络的 MTU，最大限度地利用网络带宽，确保传输的连续性和高效性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>简化错误处理&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用 MSS 限制 TCP 报文段大小可以降低由于 IP 分片引起的重传和错误处理的复杂度。如果发生数据丢失，整个 TCP 报文段丢失时，只需要重传一个比较小的单元，而不是一个由多个分片组成的大数据包。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>协商与兼容性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在 TCP 三次握手过程中，双方会交换 MSS 值，明确双方所能接受的最大报文段大小。这种协商有助于两端在一个共同的限制下进行通信，从而确保数据传输更加稳定和兼容不同网络环境。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="tcp-的粘包拆包以及解决方案">TCP 的粘包、拆包以及解决方案
&lt;/h2>&lt;p>&lt;img src="https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.jpeg"
width="1568"
height="1182"
srcset="https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85_hu_59cd60b8110afc0d.jpeg 480w, https://blog.ltlyl.fun/p/%E5%85%B3%E4%BA%8Etcp/udp%E7%9A%84%E7%AC%94%E8%AE%B0/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85_hu_2c3837d336d7b176.jpeg 1024w"
loading="lazy"
alt="粘包拆包"
class="gallery-image"
data-flex-grow="132"
data-flex-basis="318px"
>&lt;/p>
&lt;p>上图中演示了以下几种情况：&lt;/p>
&lt;ul>
&lt;li>正常的理想情况，两个包恰好满足 TCP 缓冲区的大小或达到 TCP 等待时长，分别发送两个包；&lt;/li>
&lt;li>粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；&lt;/li>
&lt;li>拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；&lt;/li>
&lt;li>拆包和粘包：Packet1 过大，进行了拆包处理，而拆出去的一部分又与 Packet2 进行粘包处理。&lt;/li>
&lt;/ul>
&lt;h3 id="什么是粘包">什么是粘包？
&lt;/h3>&lt;p>指 TCP 协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。&lt;/p>
&lt;p>TCP 是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。&lt;/p>
&lt;h3 id="为什么-udp-没有粘包">为什么 UDP 没有粘包？
&lt;/h3>&lt;p>粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于 UDP 有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在 TCP 协议中。&lt;/p>
&lt;h3 id="粘包拆包发生场景">粘包拆包发生场景
&lt;/h3>&lt;p>因为 TCP 是面向流，没有边界，而操作系统在发送 TCP 数据时，会通过缓冲区来进行优化，例如缓冲区为 1024 个字节大小。&lt;/p>
&lt;p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。&lt;/p>
&lt;p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送，这就是拆包。&lt;/p>
&lt;h3 id="常见的解决方案">常见的解决方案
&lt;/h3>&lt;ul>
&lt;li>发送端将每个包都封装成固定的长度，比如 100 字节大小。如果不足 100 字节可通过补 0 或空等进行填充到指定长度；&lt;/li>
&lt;li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n 进行合并；例如，FTP 协议；&lt;/li>
&lt;li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；&lt;/li>
&lt;li>通过自定义协议进行粘包和拆包的处理。&lt;/li>
&lt;/ul>
&lt;h2 id="重传机制">重传机制
&lt;/h2>&lt;h3 id="超时重传以时间驱动">超时重传（以时间驱动）
&lt;/h3>&lt;p>RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。&lt;/p>
&lt;p>超时重传时间是以 RTO(Retransmission Timeout 超时重传时间)表示。&lt;/p>
&lt;p>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差。&lt;/p>
&lt;p>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。&lt;/p>
&lt;p>根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。&lt;/p>
&lt;h3 id="快速重传以数据驱动">快速重传（以数据驱动）
&lt;/h3>&lt;p>发送方发出了 1，2，3，4，5 份数据:
第一份 Seq1 先送到了，于是就 Ack 回 2;结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2;后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2 因为 Seq2 还是没有收到。&lt;/p>
&lt;p>发送端收到了三个 Ack =2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。&lt;/p>
&lt;p>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6。&lt;/p>
&lt;p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。&lt;/p>
&lt;p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。&lt;/p>
&lt;h3 id="sack-方法">SACK 方法
&lt;/h3>&lt;p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。&lt;/p>
&lt;h3 id="duplicate-sack-方法">Duplicate SACK 方法
&lt;/h3>&lt;p>Duplicate SACK 又称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。&lt;/p>
&lt;h2 id="滑动窗口">滑动窗口
&lt;/h2>&lt;p>TCP 滑动窗口是一种流量控制机制，用于管理在发送端和接收端之间传输的数据量，其基本原理如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>发送窗口&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>发送端维护一个窗口，表示允许发送但尚未收到确认的数据范围。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>接收窗口&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>接收端根据自身缓冲区大小，通过 ACK 报文告知发送端当前可接收的数据量，这就是接收窗口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>窗口滑动&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当发送端收到 ACK 确认后，窗口向前移动，释放已确认的数据位置，从而可以继续发送新的数据。&lt;/li>
&lt;li>这种“滑动”过程确保了数据的连续传输，同时防止发送端发送过多数据导致接收端溢出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="流量控制">流量控制
&lt;/h2>&lt;p>TCP 流量控制是一种确保数据传输双方保持平衡的机制。其主要目标是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>保护接收端&lt;/strong>：避免发送速率超过接收端处理能力，防止数据丢失或缓冲区溢出。&lt;/li>
&lt;li>&lt;strong>动态调整数据流&lt;/strong>：通过接收端反馈的窗口大小，发送端能够动态决定一次可以发送多少数据，确保高效且稳定的数据传输。&lt;/li>
&lt;/ul>
&lt;p>简单来说，TCP 流量控制就是通过交换窗口大小信息，使发送方根据接收方的当前处理能力来决定发送数据的速率，从而保持整个数据传输过程的可靠性和高效性。&lt;/p>
&lt;h2 id="拥塞控制">拥塞控制
&lt;/h2>&lt;p>TCP 拥塞控制是一种确保网络稳定和高效的数据传输机制，其主要目标是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>预防网络拥塞&lt;/strong>：通过检测数据包丢失、延迟增大等现象，判断网络是否发生拥堵。&lt;/li>
&lt;li>&lt;strong>动态调整发送速率&lt;/strong>：在网络出现拥堵迹象时，降低发送窗口大小或发送速率；当网络状况改善时，逐步增加速率。&lt;/li>
&lt;li>&lt;strong>维护传输效率&lt;/strong>：在避免网络拥堵的同时，尽可能利用可用带宽实现高效的数据传输。&lt;/li>
&lt;/ul>
&lt;p>简单来说，TCP 拥塞控制就是通过动态调整数据发送速率来应对网络拥堵，确保数据传输既稳定又高效。&lt;/p></description></item></channel></rss>